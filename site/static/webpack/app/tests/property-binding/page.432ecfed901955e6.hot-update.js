"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tests/property-binding/page",{

/***/ "(app-pages-browser)/./src/chemistry.ts":
/*!**************************!*\
  !*** ./src/chemistry.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $Chemical: () => (/* binding */ $Chemical),\n/* harmony export */   child: () => (/* binding */ child),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   entail: () => (/* binding */ entail),\n/* harmony export */   equate: () => (/* binding */ equate),\n/* harmony export */   fifth: () => (/* binding */ fifth),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   fourth: () => (/* binding */ fourth),\n/* harmony export */   inert: () => (/* binding */ inert),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   second: () => (/* binding */ second),\n/* harmony export */   third: () => (/* binding */ third),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   where: () => (/* binding */ where)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_ts_decorate */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ $Chemical,inert,equate,dynamic,entail,transform,child,optional,where,position,first,second,third,fourth,fifth auto */ \n\n// Symbol for tracking reactified objects\nconst reactivated = Symbol('reactivated');\nconst backingFields = Symbol('backingFields');\nconst originalValues = Symbol('originalValues');\nconst deactivated = Symbol('deactivated');\nconst comparerSymbol = Symbol('comparer');\n// Near the top of the file, with other symbols and constants\nconst componentUpdaters = new WeakMap();\n/**\n * Base class for Chemical components\n */ class $Chemical {\n    // Public methods\n    view() {\n        return this.elements;\n    }\n    // Private methods\n    createComponent() {\n        const self = this;\n        const ChemicalComponent = (props)=>{\n            const instance = self.createInstance();\n            const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n                \"ChemicalComponent.useEffect\": ()=>{\n                    self.setupInstance(instance, props, {\n                        \"ChemicalComponent.useEffect\": ()=>forceUpdate({})\n                    }[\"ChemicalComponent.useEffect\"]);\n                    return ({\n                        \"ChemicalComponent.useEffect\": ()=>self.cleanupInstance(instance)\n                    })[\"ChemicalComponent.useEffect\"];\n                }\n            }[\"ChemicalComponent.useEffect\"], []);\n            self.processChildren(instance, props);\n            return instance.view();\n        };\n        ChemicalComponent.isChemical = true;\n        return ChemicalComponent;\n    }\n    createInstance() {\n        const instance = Object.create(this);\n        instance.children = [];\n        return instance;\n    }\n    setupInstance(instance, props, forceUpdate) {\n        this.applyProps(instance, props);\n        this.setupReactivity(instance, forceUpdate);\n        this.handleParentBinding(instance, props);\n        this.runCatalystMethods(instance);\n    }\n    cleanupInstance(instance) {\n        componentUpdaters.delete(instance);\n        if (instance.parent) {\n            this.unregisterFromParent(instance, instance.parent);\n        }\n    }\n    applyProps(instance, props) {\n        if (!props) return;\n        for(const key in props){\n            if (props.hasOwnProperty(key) && key !== 'children' && key !== '__parentInstance') {\n                this.setProp(instance, key, props[key]);\n            }\n        }\n    }\n    setProp(instance, key, value) {\n        const componentKey = '$' + String(key);\n        const transformers = instance.constructor.prototype.transformers;\n        if (transformers === null || transformers === void 0 ? void 0 : transformers.has(componentKey)) {\n            const transformer = transformers.get(componentKey);\n            instance[componentKey] = transformer(value);\n        } else {\n            instance[componentKey] = value;\n        }\n    }\n    setupReactivity(instance, forceUpdate) {\n        componentUpdaters.set(instance, forceUpdate);\n        decorate(instance, {\n            after: (className, memberName, memberType, method, args, result)=>{\n                if (memberType === 'field') {\n                    const updateFn = componentUpdaters.get(instance);\n                    if (updateFn) updateFn();\n                }\n                return result;\n            }\n        });\n    }\n    handleParentBinding(instance, props) {\n        console.log('handleParentBinding called', props);\n        if (!props.__parentInstance) {\n            console.log('No parent instance in props');\n            return;\n        }\n        instance.parent = props.__parentInstance;\n        console.log('Registering child with parent: ' + props.__parentInstance);\n        if (instance.parent) this.registerWithParent(instance, instance.parent);\n    }\n    registerWithParent(child, parent) {\n        this.trackChild(parent, child);\n        this.applyBinding(child, parent);\n    }\n    trackChild(parent, child) {\n        if (!parent.children.includes(child)) {\n            parent.children.push(child);\n        }\n    }\n    untrackChild(parent, child) {\n        const index = parent.children.indexOf(child);\n        if (index >= 0) {\n            parent.children.splice(index, 1);\n        }\n    }\n    applyBinding(child, parent) {\n        const bindings = getBindings(parent);\n        console.log('applyBinding - bindings:', bindings);\n        console.log('applyBinding - child:', child);\n        console.log('applyBinding - parent:', parent);\n        if (!parent.childPositionCounts) {\n            parent.childPositionCounts = new Map();\n        }\n        for (const binding of bindings){\n            if (binding.property === 'children') continue;\n            console.log('Checking binding:', binding);\n            if (this.matchesBinding(child, parent, binding)) {\n                console.log('Binding matched! Applying...');\n                this.bindChild(child, parent, binding);\n                break;\n            }\n        }\n    }\n    matchesBinding(child, parent, binding) {\n        if (!(child instanceof binding.class)) return false;\n        if (binding.position !== undefined) {\n            const count = parent.childPositionCounts.get(binding.class) || 0;\n            if (binding.position !== count) {\n                parent.childPositionCounts.set(binding.class, count + 1);\n                return false;\n            }\n            parent.childPositionCounts.set(binding.class, count + 1);\n        }\n        if (binding.where && !binding.where(child)) return false;\n        return true;\n    }\n    bindChild(child, parent, binding) {\n        const prop = parent[binding.property];\n        if (Array.isArray(prop)) {\n            prop.push(child);\n        } else if (!parent[binding.property]) {\n            parent[binding.property] = child;\n        }\n    }\n    unbindChild(child, parent) {\n        const bindings = getBindings(parent);\n        for (const binding of bindings){\n            if (binding.property === 'children') continue;\n            const prop = parent[binding.property];\n            if (Array.isArray(prop)) {\n                const index = prop.indexOf(child);\n                if (index >= 0) prop.splice(index, 1);\n            } else if (parent[binding.property] === child) {\n                parent[binding.property] = undefined;\n            }\n        }\n    }\n    unregisterFromParent(child, parent) {\n        this.unbindChild(child, parent);\n        this.untrackChild(parent, child);\n    }\n    runCatalystMethods(instance) {\n        const methods = instance.constructor.prototype.catalystMethods;\n        if (!methods) return;\n        for (const methodName of methods){\n            if (typeof instance[methodName] === 'function') {\n                instance[methodName]();\n            }\n        }\n    }\n    processChildren(instance, props) {\n        if (!(props === null || props === void 0 ? void 0 : props.children)) return;\n        const modifiedChildren = this.modifyChildren(instance, props.children);\n        instance.elements = modifiedChildren;\n    }\n    modifyChildren(instance, children) {\n        console.log('modifyChildren called, instance:', instance);\n        const childrenArray = react__WEBPACK_IMPORTED_MODULE_0___default().Children.toArray(children);\n        console.log('childrenArray:', childrenArray);\n        return childrenArray.map((child)=>{\n            if (react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(child) && child.type.isChemical) {\n                console.log('Found Chemical child, adding __parentInstance');\n                return react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(child, {\n                    ...child.props,\n                    __parentInstance: instance\n                });\n            }\n            return child;\n        });\n    }\n    createFragment(above, main, below) {\n        const children = [];\n        if (above) children.push(above);\n        if (main) children.push(main);\n        if (below) children.push(below);\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, ...children);\n    }\n    // Constructor\n    constructor(){\n        this.children = [];\n        this.Component = this.createComponent();\n    }\n}\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__.__decorate)([\n    inert()\n], $Chemical.prototype, \"Component\", void 0);\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__.__decorate)([\n    inert()\n], $Chemical.prototype, \"parent\", void 0);\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__.__decorate)([\n    inert()\n], $Chemical.prototype, \"children\", void 0);\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__.__decorate)([\n    inert()\n], $Chemical.prototype, \"elements\", void 0);\n/**\n * Get merged bindings for a Chemical instance\n */ function getBindings(instance) {\n    const constructor = instance.constructor;\n    // Return cached if available\n    if (constructor._mergedBindings) {\n        return constructor._mergedBindings;\n    }\n    // Build merged map\n    const mergedMap = new Map();\n    // Walk up prototype chain, child bindings override parent\n    let proto = constructor;\n    while(proto && proto !== $Chemical){\n        if (proto.__bindingsMap) {\n            proto.__bindingsMap.forEach((binding, key)=>{\n                // Only add if not already set by child class\n                if (!mergedMap.has(key)) {\n                    mergedMap.set(key, {\n                        ...binding,\n                        property: key\n                    });\n                }\n            });\n        }\n        proto = Object.getPrototypeOf(proto);\n    }\n    // Convert to array, filter invalid, and sort\n    const bindings = [];\n    mergedMap.forEach((binding)=>{\n        if (!binding.class) {\n            console.warn(\"Binding for '\".concat(binding.property, \"' missing @child decorator\"));\n            return;\n        }\n        bindings.push(binding);\n    });\n    // Sort: indexed first, then by index value\n    bindings.sort((a, b)=>{\n        if (a.position !== undefined && b.position === undefined) return -1;\n        if (b.position !== undefined && a.position === undefined) return 1;\n        if (a.position !== undefined && b.position !== undefined) {\n            return a.position - b.position;\n        }\n        return 0;\n    });\n    // Cache and return\n    constructor._mergedBindings = bindings;\n    return bindings;\n}\n/**\n * Reactivates an object, making its properties reactive\n */ function reactivate(instance, owner) {\n    // Already marked as reactivated in component\n    if (instance[reactivated]) {\n        return instance;\n    }\n    instance[reactivated] = true;\n    const triggerUpdate = ()=>{\n        const updateFn = componentUpdaters.get(owner || instance);\n        if (updateFn) updateFn();\n    };\n    decorate(instance, {\n        after: (className, memberName, memberType, method, args, result)=>{\n            if (memberType === 'field') {\n                triggerUpdate();\n            }\n            return result;\n        }\n    });\n    // Only reactify non-Chemical objects\n    for(const key in instance){\n        if (key !== 'constructor' && !key.startsWith('_')) {\n            const value = instance[key];\n            // Skip Chemical instances - they manage themselves\n            if (!(value instanceof $Chemical) && value && typeof value === 'object' && !(value instanceof Date)) {\n                if (Array.isArray(value)) {\n                    value.forEach((item)=>{\n                        if (!(item instanceof $Chemical) && item && typeof item === 'object') {\n                            reactivateData(item, owner || instance);\n                        }\n                    });\n                } else {\n                    reactivateData(value, owner || instance);\n                }\n            }\n        }\n    }\n    return instance;\n}\n/**\n * Reactivates a nested data object in an object or field \n */ function reactivateData(obj, owner) {\n    if (!obj || typeof obj !== 'object' || obj[reactivated] || obj instanceof $Chemical) {\n        return;\n    }\n    reactivate(obj, owner);\n}\n/**\n * Deactivates an object, preventing it from triggering updates\n * This is exported for advanced usage but generally should be used via Chemical.deactivate\n */ function deactivate(instance) {\n    // Mark as deactivated\n    instance[deactivated] = true;\n    return instance;\n}\n/**\n * Decorator to mark a field as inert (non-reactive)\n */ function inert() {\n    return function(target, propertyKey) {\n        // Create or get the inert properties set\n        if (!target[deactivated]) {\n            target[deactivated] = new Set();\n        }\n        // Add this property to the inert set\n        target[deactivated].add(propertyKey);\n    };\n}\n/**\n * Decorator to specify a custom equality comparison for a field\n */ function equate(comparer) {\n    return function(target, propertyKey) {\n        // Create or get the property comparers map\n        if (!target[comparerSymbol]) {\n            target[comparerSymbol] = new Map();\n        }\n        // Add the custom comparer for this property\n        target[comparerSymbol].set(propertyKey, comparer);\n    };\n}\n/**\n * Decorator for properties that should use deep equality comparison\n * Useful for arrays, collections, and complex objects\n */ function dynamic() {\n    return function(target, propertyKey) {\n        // Create or get the property comparers map\n        if (!target[comparerSymbol]) {\n            target[comparerSymbol] = new Map();\n        }\n        // Add a JSON-based deep comparer for this property\n        target[comparerSymbol].set(propertyKey, (a, b)=>{\n            try {\n                return JSON.stringify(a) === JSON.stringify(b);\n            } catch (e) {\n                // If stringify fails (circular refs, etc.), fall back to reference equality\n                return a === b;\n            }\n        });\n    };\n}\n/**\n * Decorator for methods that should run after component rendering\n */ function entail() {\n    return function(target, propertyKey, descriptor) {\n        const originalMethod = descriptor.value;\n        // Create or get the catalysts methods set\n        if (!target.catalystMethods) {\n            target.catalystMethods = new Set();\n        }\n        // Add this method to the catalysts set\n        target.catalystMethods.add(propertyKey);\n        // Return the original descriptor\n        return descriptor;\n    };\n}\n/**\n * Decorator for properties that should run the value through a transformation function\n */ function transform(transformer) {\n    return function(target, propertyKey) {\n        // Create or get the transformers map\n        if (!target.transformers) {\n            target.transformers = new Map();\n        }\n        // Add the transformer for this property\n        target.transformers.set(propertyKey, transformer);\n    };\n}\n/**\n * Decorator for binding a child to a property\n */ function child(ChildClass) {\n    return function(target, propertyKey) {\n        const constructor = target.constructor;\n        if (!constructor.__bindingsMap) constructor.__bindingsMap = new Map();\n        let binding = constructor.__bindingsMap.get(propertyKey);\n        if (!binding) {\n            binding = {\n                property: propertyKey\n            };\n            constructor.__bindingsMap.set(propertyKey, binding);\n        }\n        binding.class = ChildClass;\n        if (binding.optional === undefined) binding.optional = false;\n    };\n}\n/**\n * Decorator for positional child property binding\n */ function optional() {\n    return function(target, propertyKey) {\n        const constructor = target.constructor;\n        if (!constructor.__bindingsMap) constructor.__bindingsMap = new Map();\n        let binding = constructor.__bindingsMap.get(propertyKey);\n        if (!binding) {\n            binding = {\n                property: propertyKey\n            };\n            constructor.__bindingsMap.set(propertyKey, binding);\n        }\n        binding.optional = true;\n    };\n}\n/**\n * Decorator for conditional child property binding\n */ function where(predicate) {\n    return function(target, propertyKey) {\n        const constructor = target.constructor;\n        if (!constructor.__bindingsMap) constructor.__bindingsMap = new Map();\n        let binding = constructor.__bindingsMap.get(propertyKey);\n        if (!binding) {\n            binding = {\n                property: propertyKey\n            };\n            constructor.__bindingsMap.set(propertyKey, binding);\n        }\n        binding.where = predicate;\n    };\n}\n/**\n * Decorator for positional child property binding\n */ function position(n) {\n    return function(target, propertyKey) {\n        const constructor = target.constructor;\n        if (!constructor.__bindingsMap) constructor.__bindingsMap = new Map();\n        let binding = constructor.__bindingsMap.get(propertyKey);\n        if (!binding) {\n            binding = {\n                property: propertyKey\n            };\n            constructor.__bindingsMap.set(propertyKey, binding);\n        }\n        binding.position = n - 1; // 0-based\n    };\n}\n// Convencience child binding decorators for different positions\nconst first = position(1);\nconst second = position(2);\nconst third = position(3);\nconst fourth = position(4);\nconst fifth = position(5);\n/**\n * Decorates an object's methods and properties with interceptors\n */ function decorate(instance, config) {\n    var _instance_constructor;\n    // Skip if already decorated\n    if (instance[reactivated]) {\n        return instance;\n    }\n    var _instance_constructor_name;\n    const className = (_instance_constructor_name = instance === null || instance === void 0 ? void 0 : (_instance_constructor = instance.constructor) === null || _instance_constructor === void 0 ? void 0 : _instance_constructor.name) !== null && _instance_constructor_name !== void 0 ? _instance_constructor_name : \"<UNKNOWN>\";\n    // Store original values\n    instance[backingFields] = {};\n    instance[originalValues] = {};\n    // Process properties and fields\n    decorateProperties(instance, className, config);\n    // Mark as reactified\n    instance[reactivated] = true;\n    return instance;\n}\n/**\n * Decorates properties of an object with interceptors\n */ function decorateProperties(instance, className, config) {\n    const properties = getAllProperties(instance);\n    for (const key of properties){\n        // Skip internal properties and methods we've already processed\n        if (key === 'constructor' || key === String(reactivated) || key === String(backingFields) || key === String(originalValues) || key === 'state' || key === 'props' || typeof instance[key] === 'function' || $Chemical.prototype.hasOwnProperty(key) || // Skip Chemical base class properties\n        instance[key] instanceof $Chemical) {\n            continue;\n        }\n        // Check if this is already an accessor property\n        const descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(instance), key);\n        if (descriptor && (descriptor.get || descriptor.set)) {\n            // Handle accessor property\n            decorateAccessorProperty(instance, key, descriptor, className, config);\n            continue;\n        }\n        // Handle regular data property\n        // Store original value\n        instance[backingFields][key] = instance[key];\n        // Replace with getter/setter for regular properties\n        Object.defineProperty(instance, key, {\n            get: function() {\n                const value = this[backingFields][key];\n                if (config.after) {\n                    const afterResult = config.after(className, key, 'property', ()=>{}, [], value);\n                    return afterResult !== null && afterResult !== void 0 ? afterResult : value;\n                }\n                return value;\n            },\n            set: function(newValue) {\n                const oldValue = this[backingFields][key];\n                // Skip update if values are equal\n                if (oldValue === newValue) {\n                    return;\n                }\n                // Check for custom comparer\n                const proto = Object.getPrototypeOf(this);\n                const hasCustomComparer = proto && proto[comparerSymbol] && proto[comparerSymbol].has(key);\n                if (hasCustomComparer) {\n                    const customComparer = proto[comparerSymbol].get(key);\n                    if (customComparer(oldValue, newValue)) {\n                        return; // Skip update if custom comparer says they're equal\n                    }\n                }\n                let valueToSet = newValue;\n                // Apply before logic if available\n                if (config.before) {\n                    const beforeResult = config.before(className, key, 'field', ()=>{}, [\n                        newValue\n                    ]);\n                    if (beforeResult && beforeResult[1]) {\n                        valueToSet = beforeResult[1][0];\n                    }\n                }\n                // Handle frozen/sealed objects\n                if (valueToSet && typeof valueToSet === 'object') {\n                    // Skip reactification for frozen/sealed objects and Chemical instances\n                    if (!Object.isFrozen(valueToSet) && !Object.isSealed(valueToSet) && Object.isExtensible(valueToSet) && !(valueToSet instanceof $Chemical)) {\n                        // Deep reactify complex objects\n                        if (!Array.isArray(valueToSet) && !(valueToSet instanceof Date)) {\n                            reactivateData(valueToSet, this);\n                        }\n                    }\n                }\n                // Set the new value\n                this[backingFields][key] = valueToSet;\n                // Apply after logic\n                if (config.after) {\n                    config.after(className, key, 'field', ()=>{}, [\n                        valueToSet\n                    ], undefined);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n    }\n}\n/**\n * Decorates an accessor property (getter/setter)\n */ function decorateAccessorProperty(instance, key, descriptor, className, config) {\n    const originalGet = descriptor.get;\n    const originalSet = descriptor.set;\n    Object.defineProperty(instance, key, {\n        get: function() {\n            // Preserve original getter behavior\n            const value = originalGet === null || originalGet === void 0 ? void 0 : originalGet.call(this);\n            if (config.after) {\n                const afterResult = config.after(className, key, 'property', ()=>{}, [], value);\n                return afterResult !== null && afterResult !== void 0 ? afterResult : value;\n            }\n            return value;\n        },\n        set: function(newValue) {\n            if (!originalSet) return; // Read-only property\n            const oldValue = originalGet === null || originalGet === void 0 ? void 0 : originalGet.call(this);\n            // Skip update if values are equal\n            if (oldValue === newValue) {\n                return;\n            }\n            // Check for custom comparer\n            const proto = Object.getPrototypeOf(this);\n            const hasCustomComparer = proto && proto[comparerSymbol] && proto[comparerSymbol].has(key);\n            if (hasCustomComparer) {\n                const customComparer = proto[comparerSymbol].get(key);\n                if (customComparer(oldValue, newValue)) {\n                    return; // Skip update if custom comparer says they're equal\n                }\n            }\n            // Call original setter\n            originalSet.call(this, newValue);\n            // Apply after logic to trigger updates\n            if (config.after) {\n                config.after(className, key, 'field', ()=>{}, [\n                    newValue\n                ], undefined);\n            }\n        },\n        enumerable: descriptor.enumerable,\n        configurable: descriptor.configurable\n    });\n}\n/**\n * Checks if an object is a base object method\n */ function isBaseObjectMethod(methodName) {\n    return Object.prototype.hasOwnProperty.call(Object.prototype, methodName);\n}\n/**\n * Gets all methods from an object and its prototype chain\n */ function getAllMethods(obj) {\n    const methods = {};\n    let proto = obj;\n    while(proto && proto !== Object.prototype){\n        for(const key in proto){\n            if (methods[key]) continue;\n            if (typeof proto[key] === \"function\" && !key.startsWith(\"_\") && // Skip private methods\n            !isBaseObjectMethod(key)) {\n                methods[key] = proto[key];\n            }\n        }\n        proto = proto.__proto__;\n    }\n    return methods;\n}\n/**\n * Gets all properties from an object\n */ function getAllProperties(obj) {\n    const properties = new Set();\n    // Get own properties\n    Object.getOwnPropertyNames(obj).forEach((prop)=>{\n        properties.add(prop);\n    });\n    // Get properties from prototype chain\n    let proto = Object.getPrototypeOf(obj);\n    while(proto && proto !== Object.prototype){\n        Object.getOwnPropertyNames(proto).forEach((prop)=>{\n            if (!prop.startsWith('_') && prop !== 'constructor') {\n                properties.add(prop);\n            }\n        });\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Array.from(properties);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TXJDLFVBQXVDLENBQUM7SUFDOUMsSUFBSXNCLFFBQVFlO0lBRVosTUFBT2YsU0FBU0EsVUFBVW5GLE9BQU9pQixTQUFTLENBQUU7UUFDeEMsSUFBSyxNQUFNUCxPQUFPeUUsTUFBTztZQUNyQixJQUFJdEIsT0FBTyxDQUFDbkQsSUFBSSxFQUFFO1lBQ2xCLElBQ0ksT0FBT3lFLEtBQUssQ0FBQ3pFLElBQUksS0FBSyxjQUN0QixDQUFDQSxJQUFJb0YsVUFBVSxDQUFDLFFBQVEsdUJBQXVCO1lBQy9DLENBQUNzRCxtQkFBbUIxSSxNQUN0QjtnQkFDRW1ELE9BQU8sQ0FBQ25ELElBQUksR0FBR3lFLEtBQUssQ0FBQ3pFLElBQUk7WUFDN0I7UUFDSjtRQUNBeUUsUUFBUUEsTUFBTW1FLFNBQVM7SUFDM0I7SUFFQSxPQUFPekY7QUFDWDtBQUVBOztDQUVDLEdBQ0QsU0FBU21FLGlCQUFpQjlCLEdBQVE7SUFDOUIsTUFBTTZCLGFBQWEsSUFBSXhCO0lBRXZCLHFCQUFxQjtJQUNyQnZHLE9BQU91SixtQkFBbUIsQ0FBQ3JELEtBQUtiLE9BQU8sQ0FBQzVCLENBQUFBO1FBQ3BDc0UsV0FBV3ZCLEdBQUcsQ0FBQy9DO0lBQ25CO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUkwQixRQUFRbkYsT0FBT3NGLGNBQWMsQ0FBQ1k7SUFDbEMsTUFBT2YsU0FBU0EsVUFBVW5GLE9BQU9pQixTQUFTLENBQUU7UUFDeENqQixPQUFPdUosbUJBQW1CLENBQUNwRSxPQUFPRSxPQUFPLENBQUM1QixDQUFBQTtZQUN0QyxJQUFJLENBQUNBLEtBQUtxQyxVQUFVLENBQUMsUUFBUXJDLFNBQVMsZUFBZTtnQkFDakRzRSxXQUFXdkIsR0FBRyxDQUFDL0M7WUFDbkI7UUFDSjtRQUNBMEIsUUFBUW5GLE9BQU9zRixjQUFjLENBQUNIO0lBQ2xDO0lBRUEsT0FBT3pCLE1BQU04RixJQUFJLENBQUN6QjtBQUN0QiIsInNvdXJjZXMiOlsiL2hvbWUvZG91Zy9yZXBvcy9kbmEtcGxhdGZvcm0vY2hlbWlzdHJ5L3NyYy9jaGVtaXN0cnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCBSZWFjdCwgeyBSZWFjdE5vZGUsIFJlYWN0RWxlbWVudCwgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyBTeW1ib2wgZm9yIHRyYWNraW5nIHJlYWN0aWZpZWQgb2JqZWN0c1xuY29uc3QgcmVhY3RpdmF0ZWQgPSBTeW1ib2woJ3JlYWN0aXZhdGVkJyk7XG5jb25zdCBiYWNraW5nRmllbGRzID0gU3ltYm9sKCdiYWNraW5nRmllbGRzJyk7XG5jb25zdCBvcmlnaW5hbFZhbHVlcyA9IFN5bWJvbCgnb3JpZ2luYWxWYWx1ZXMnKTtcbmNvbnN0IGRlYWN0aXZhdGVkID0gU3ltYm9sKCdkZWFjdGl2YXRlZCcpO1xuY29uc3QgY29tcGFyZXJTeW1ib2wgPSBTeW1ib2woJ2NvbXBhcmVyJyk7XG5cbi8vIE5lYXIgdGhlIHRvcCBvZiB0aGUgZmlsZSwgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCBjb25zdGFudHNcbmNvbnN0IGNvbXBvbmVudFVwZGF0ZXJzID0gbmV3IFdlYWtNYXA8b2JqZWN0LCAoKSA9PiB2b2lkPigpO1xuXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IGFsbG93cyB5b3UgdG8gdXNlIGZpZWxkcyBwcmVmaXhlZCB3aXRoICQgYXMgcHJvcHNcbiAqL1xudHlwZSBQcm9wZXJ0aWVzPFQ+ID0ge1xuICAgIFtLIGluIGtleW9mIFQgYXMgSyBleHRlbmRzIGAkJHtpbmZlciBSZXN0fWAgPyBSZXN0IDogbmV2ZXJdOiBUW0tdXG59ICYge1xuICAgIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBDaGVtaWNhbCBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyAkQ2hlbWljYWwge1xuICAgIC8vIFByaXZhdGUgZmllbGRzXG4gICAgcHJpdmF0ZSBjaGlsZFBvc2l0aW9uQ291bnRzPzogTWFwPGFueSwgbnVtYmVyPjtcblxuICAgIC8vIFB1YmxpYyBpbmVydCBwcm9wZXJ0aWVzXG4gICAgQGluZXJ0KClcbiAgICBwdWJsaWMgQ29tcG9uZW50ITogUmVhY3QuRkM8UHJvcGVydGllczx0aGlzPj47XG5cbiAgICBAaW5lcnQoKVxuICAgIHB1YmxpYyBwYXJlbnQ/OiAkQ2hlbWljYWw7XG5cbiAgICBAaW5lcnQoKVxuICAgIHB1YmxpYyBjaGlsZHJlbjogJENoZW1pY2FsW10gPSBbXTtcblxuICAgIEBpbmVydCgpXG4gICAgcHVibGljIGVsZW1lbnRzPzogUmVhY3ROb2RlO1xuXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5Db21wb25lbnQgPSB0aGlzLmNyZWF0ZUNvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIC8vIFB1YmxpYyBtZXRob2RzXG4gICAgdmlldygpOiBSZWFjdE5vZGUge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgICBwcml2YXRlIGNyZWF0ZUNvbXBvbmVudCgpOiBSZWFjdC5GQzxQcm9wZXJ0aWVzPHRoaXM+PiB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IENoZW1pY2FsQ29tcG9uZW50OiBSZWFjdC5GQzxQcm9wZXJ0aWVzPHRoaXM+PiA9IChwcm9wczogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHNlbGYuY3JlYXRlSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKHt9KTtcblxuICAgICAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldHVwSW5zdGFuY2UoaW5zdGFuY2UsIHByb3BzLCAoKSA9PiBmb3JjZVVwZGF0ZSh7fSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBzZWxmLmNsZWFudXBJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgIHNlbGYucHJvY2Vzc0NoaWxkcmVuKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UudmlldygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIChDaGVtaWNhbENvbXBvbmVudCBhcyBhbnkpLmlzQ2hlbWljYWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gQ2hlbWljYWxDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVJbnN0YW5jZSgpOiAkQ2hlbWljYWwge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgIGluc3RhbmNlLmNoaWxkcmVuID0gW107XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwSW5zdGFuY2UoaW5zdGFuY2U6ICRDaGVtaWNhbCwgcHJvcHM6IGFueSwgZm9yY2VVcGRhdGU6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hcHBseVByb3BzKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICAgIHRoaXMuc2V0dXBSZWFjdGl2aXR5KGluc3RhbmNlLCBmb3JjZVVwZGF0ZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFyZW50QmluZGluZyhpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgICB0aGlzLnJ1bkNhdGFseXN0TWV0aG9kcyhpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbGVhbnVwSW5zdGFuY2UoaW5zdGFuY2U6ICRDaGVtaWNhbCk6IHZvaWQge1xuICAgICAgICBjb21wb25lbnRVcGRhdGVycy5kZWxldGUoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJGcm9tUGFyZW50KGluc3RhbmNlLCBpbnN0YW5jZS5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseVByb3BzKGluc3RhbmNlOiAkQ2hlbWljYWwsIHByb3BzOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFwcm9wcykgcmV0dXJuO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ2NoaWxkcmVuJyAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ19fcGFyZW50SW5zdGFuY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9wKGluc3RhbmNlLCBrZXksIHByb3BzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRQcm9wKGluc3RhbmNlOiAkQ2hlbWljYWwsIGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEtleSA9ICckJyArIFN0cmluZyhrZXkpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHJhbnNmb3JtZXJzO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lcnM/Lmhhcyhjb21wb25lbnRLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVycy5nZXQoY29tcG9uZW50S2V5KTtcbiAgICAgICAgICAgIChpbnN0YW5jZSBhcyBhbnkpW2NvbXBvbmVudEtleV0gPSB0cmFuc2Zvcm1lcih2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAoaW5zdGFuY2UgYXMgYW55KVtjb21wb25lbnRLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwUmVhY3Rpdml0eShpbnN0YW5jZTogJENoZW1pY2FsLCBmb3JjZVVwZGF0ZTogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBjb21wb25lbnRVcGRhdGVycy5zZXQoaW5zdGFuY2UsIGZvcmNlVXBkYXRlKTtcblxuICAgICAgICBkZWNvcmF0ZShpbnN0YW5jZSwge1xuICAgICAgICAgICAgYWZ0ZXI6IChjbGFzc05hbWUsIG1lbWJlck5hbWUsIG1lbWJlclR5cGUsIG1ldGhvZCwgYXJncywgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbWJlclR5cGUgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlRm4gPSBjb21wb25lbnRVcGRhdGVycy5nZXQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlRm4pIHVwZGF0ZUZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlUGFyZW50QmluZGluZyhpbnN0YW5jZTogJENoZW1pY2FsLCBwcm9wczogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoYW5kbGVQYXJlbnRCaW5kaW5nIGNhbGxlZCcsIHByb3BzKTtcbiAgICAgICAgaWYgKCFwcm9wcy5fX3BhcmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gcGFyZW50IGluc3RhbmNlIGluIHByb3BzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0YW5jZS5wYXJlbnQgPSBwcm9wcy5fX3BhcmVudEluc3RhbmNlO1xuICAgICAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgY2hpbGQgd2l0aCBwYXJlbnQ6ICcgKyBwcm9wcy5fX3BhcmVudEluc3RhbmNlKTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJXaXRoUGFyZW50KGluc3RhbmNlLCBpbnN0YW5jZS5wYXJlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVnaXN0ZXJXaXRoUGFyZW50KGNoaWxkOiAkQ2hlbWljYWwsIHBhcmVudDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIHRoaXMudHJhY2tDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgdGhpcy5hcHBseUJpbmRpbmcoY2hpbGQsIHBhcmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmFja0NoaWxkKHBhcmVudDogJENoZW1pY2FsLCBjaGlsZDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIGlmICghcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKGNoaWxkKSkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bnRyYWNrQ2hpbGQocGFyZW50OiAkQ2hlbWljYWwsIGNoaWxkOiAkQ2hlbWljYWwpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXBwbHlCaW5kaW5nKGNoaWxkOiAkQ2hlbWljYWwsIHBhcmVudDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gZ2V0QmluZGluZ3MocGFyZW50KTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FwcGx5QmluZGluZyAtIGJpbmRpbmdzOicsIGJpbmRpbmdzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FwcGx5QmluZGluZyAtIGNoaWxkOicsIGNoaWxkKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FwcGx5QmluZGluZyAtIHBhcmVudDonLCBwYXJlbnQpO1xuXG4gICAgICAgIGlmICghcGFyZW50LmNoaWxkUG9zaXRpb25Db3VudHMpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZFBvc2l0aW9uQ291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoYmluZGluZy5wcm9wZXJ0eSA9PT0gJ2NoaWxkcmVuJykgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBiaW5kaW5nOicsIGJpbmRpbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hlc0JpbmRpbmcoY2hpbGQsIHBhcmVudCwgYmluZGluZykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmluZGluZyBtYXRjaGVkISBBcHBseWluZy4uLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZENoaWxkKGNoaWxkLCBwYXJlbnQsIGJpbmRpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXRjaGVzQmluZGluZyhjaGlsZDogJENoZW1pY2FsLCBwYXJlbnQ6ICRDaGVtaWNhbCwgYmluZGluZzogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgYmluZGluZy5jbGFzcyEpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKGJpbmRpbmcucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBwYXJlbnQuY2hpbGRQb3NpdGlvbkNvdW50cyEuZ2V0KGJpbmRpbmcuY2xhc3MpIHx8IDA7XG4gICAgICAgICAgICBpZiAoYmluZGluZy5wb3NpdGlvbiAhPT0gY291bnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRQb3NpdGlvbkNvdW50cyEuc2V0KGJpbmRpbmcuY2xhc3MhLCBjb3VudCArIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5jaGlsZFBvc2l0aW9uQ291bnRzIS5zZXQoYmluZGluZy5jbGFzcyEsIGNvdW50ICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmluZGluZy53aGVyZSAmJiAhYmluZGluZy53aGVyZShjaGlsZCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGJpbmRDaGlsZChjaGlsZDogJENoZW1pY2FsLCBwYXJlbnQ6ICRDaGVtaWNhbCwgYmluZGluZzogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHByb3AgPSAocGFyZW50IGFzIGFueSlbYmluZGluZy5wcm9wZXJ0eV07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgIHByb3AucHVzaChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIShwYXJlbnQgYXMgYW55KVtiaW5kaW5nLnByb3BlcnR5XSkge1xuICAgICAgICAgICAgKHBhcmVudCBhcyBhbnkpW2JpbmRpbmcucHJvcGVydHldID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVuYmluZENoaWxkKGNoaWxkOiAkQ2hlbWljYWwsIHBhcmVudDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gZ2V0QmluZGluZ3MocGFyZW50KTtcblxuICAgICAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnByb3BlcnR5ID09PSAnY2hpbGRyZW4nKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgcHJvcCA9IChwYXJlbnQgYXMgYW55KVtiaW5kaW5nLnByb3BlcnR5XTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcm9wLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSBwcm9wLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChwYXJlbnQgYXMgYW55KVtiaW5kaW5nLnByb3BlcnR5XSA9PT0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAocGFyZW50IGFzIGFueSlbYmluZGluZy5wcm9wZXJ0eV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVucmVnaXN0ZXJGcm9tUGFyZW50KGNoaWxkOiAkQ2hlbWljYWwsIHBhcmVudDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIHRoaXMudW5iaW5kQ2hpbGQoY2hpbGQsIHBhcmVudCk7XG4gICAgICAgIHRoaXMudW50cmFja0NoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcnVuQ2F0YWx5c3RNZXRob2RzKGluc3RhbmNlOiAkQ2hlbWljYWwpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IGluc3RhbmNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYXRhbHlzdE1ldGhvZHM7XG4gICAgICAgIGlmICghbWV0aG9kcykgcmV0dXJuO1xuXG4gICAgICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBtZXRob2RzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChpbnN0YW5jZSBhcyBhbnkpW21ldGhvZE5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgKGluc3RhbmNlIGFzIGFueSlbbWV0aG9kTmFtZV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcHJvY2Vzc0NoaWxkcmVuKGluc3RhbmNlOiAkQ2hlbWljYWwsIHByb3BzOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFwcm9wcz8uY2hpbGRyZW4pIHJldHVybjtcblxuICAgICAgICBjb25zdCBtb2RpZmllZENoaWxkcmVuID0gdGhpcy5tb2RpZnlDaGlsZHJlbihpbnN0YW5jZSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBpbnN0YW5jZS5lbGVtZW50cyA9IG1vZGlmaWVkQ2hpbGRyZW47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb2RpZnlDaGlsZHJlbihpbnN0YW5jZTogJENoZW1pY2FsLCBjaGlsZHJlbjogUmVhY3ROb2RlKTogUmVhY3ROb2RlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ21vZGlmeUNoaWxkcmVuIGNhbGxlZCwgaW5zdGFuY2U6JywgaW5zdGFuY2UpO1xuICAgICAgICBjb25zdCBjaGlsZHJlbkFycmF5ID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjaGlsZHJlbkFycmF5OicsIGNoaWxkcmVuQXJyYXkpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZHJlbkFycmF5Lm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIChjaGlsZC50eXBlIGFzIGFueSkuaXNDaGVtaWNhbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBDaGVtaWNhbCBjaGlsZCwgYWRkaW5nIF9fcGFyZW50SW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkIGFzIGFueSwge1xuICAgICAgICAgICAgICAgICAgICAuLi4oY2hpbGQucHJvcHMgYXMgYW55KSxcbiAgICAgICAgICAgICAgICAgICAgX19wYXJlbnRJbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVGcmFnbWVudChhYm92ZT86IFJlYWN0Tm9kZSwgbWFpbj86IFJlYWN0Tm9kZSwgYmVsb3c/OiBSZWFjdE5vZGUpOiBSZWFjdE5vZGUge1xuICAgICAgICBjb25zdCBjaGlsZHJlbjogUmVhY3ROb2RlW10gPSBbXTtcblxuICAgICAgICBpZiAoYWJvdmUpIGNoaWxkcmVuLnB1c2goYWJvdmUpO1xuICAgICAgICBpZiAobWFpbikgY2hpbGRyZW4ucHVzaChtYWluKTtcbiAgICAgICAgaWYgKGJlbG93KSBjaGlsZHJlbi5wdXNoKGJlbG93KTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgbWVyZ2VkIGJpbmRpbmdzIGZvciBhIENoZW1pY2FsIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldEJpbmRpbmdzKGluc3RhbmNlOiAkQ2hlbWljYWwpOiBhbnlbXSB7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBpbnN0YW5jZS5jb25zdHJ1Y3RvciBhcyBhbnk7XG5cbiAgICAvLyBSZXR1cm4gY2FjaGVkIGlmIGF2YWlsYWJsZVxuICAgIGlmIChjb25zdHJ1Y3Rvci5fbWVyZ2VkQmluZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLl9tZXJnZWRCaW5kaW5ncztcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBtZXJnZWQgbWFwXG4gICAgY29uc3QgbWVyZ2VkTWFwID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICAgIC8vIFdhbGsgdXAgcHJvdG90eXBlIGNoYWluLCBjaGlsZCBiaW5kaW5ncyBvdmVycmlkZSBwYXJlbnRcbiAgICBsZXQgcHJvdG8gPSBjb25zdHJ1Y3RvcjtcbiAgICB3aGlsZSAocHJvdG8gJiYgcHJvdG8gIT09ICRDaGVtaWNhbCkge1xuICAgICAgICBpZiAocHJvdG8uX19iaW5kaW5nc01hcCkge1xuICAgICAgICAgICAgcHJvdG8uX19iaW5kaW5nc01hcC5mb3JFYWNoKChiaW5kaW5nOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgaWYgbm90IGFscmVhZHkgc2V0IGJ5IGNoaWxkIGNsYXNzXG4gICAgICAgICAgICAgICAgaWYgKCFtZXJnZWRNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTWFwLnNldChrZXksIHsgLi4uYmluZGluZywgcHJvcGVydHk6IGtleSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0byBhcnJheSwgZmlsdGVyIGludmFsaWQsIGFuZCBzb3J0XG4gICAgY29uc3QgYmluZGluZ3M6IGFueVtdID0gW107XG4gICAgbWVyZ2VkTWFwLmZvckVhY2goYmluZGluZyA9PiB7XG4gICAgICAgIGlmICghYmluZGluZy5jbGFzcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBCaW5kaW5nIGZvciAnJHtiaW5kaW5nLnByb3BlcnR5fScgbWlzc2luZyBAY2hpbGQgZGVjb3JhdG9yYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICB9KTtcblxuICAgIC8vIFNvcnQ6IGluZGV4ZWQgZmlyc3QsIHRoZW4gYnkgaW5kZXggdmFsdWVcbiAgICBiaW5kaW5ncy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgYi5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChiLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgYS5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBiLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIC8vIENhY2hlIGFuZCByZXR1cm5cbiAgICBjb25zdHJ1Y3Rvci5fbWVyZ2VkQmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICByZXR1cm4gYmluZGluZ3M7XG59XG5cbi8qKlxuICogUmVhY3RpdmF0ZXMgYW4gb2JqZWN0LCBtYWtpbmcgaXRzIHByb3BlcnRpZXMgcmVhY3RpdmVcbiAqL1xuZnVuY3Rpb24gcmVhY3RpdmF0ZTxUIGV4dGVuZHMgb2JqZWN0PihpbnN0YW5jZTogVCwgb3duZXI/OiBhbnkpOiBUIHtcbiAgICAvLyBBbHJlYWR5IG1hcmtlZCBhcyByZWFjdGl2YXRlZCBpbiBjb21wb25lbnRcbiAgICBpZiAoKGluc3RhbmNlIGFzIGFueSlbcmVhY3RpdmF0ZWRdKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICAoaW5zdGFuY2UgYXMgYW55KVtyZWFjdGl2YXRlZF0gPSB0cnVlO1xuXG4gICAgY29uc3QgdHJpZ2dlclVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlRm4gPSBjb21wb25lbnRVcGRhdGVycy5nZXQob3duZXIgfHwgaW5zdGFuY2UpO1xuICAgICAgICBpZiAodXBkYXRlRm4pIHVwZGF0ZUZuKCk7XG4gICAgfTtcblxuICAgIGRlY29yYXRlKGluc3RhbmNlLCB7XG4gICAgICAgIGFmdGVyOiAoY2xhc3NOYW1lLCBtZW1iZXJOYW1lLCBtZW1iZXJUeXBlLCBtZXRob2QsIGFyZ3MsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lbWJlclR5cGUgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBPbmx5IHJlYWN0aWZ5IG5vbi1DaGVtaWNhbCBvYmplY3RzXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiAha2V5LnN0YXJ0c1dpdGgoJ18nKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5zdGFuY2UgYXMgYW55KVtrZXldO1xuICAgICAgICAgICAgLy8gU2tpcCBDaGVtaWNhbCBpbnN0YW5jZXMgLSB0aGV5IG1hbmFnZSB0aGVtc2VsdmVzXG4gICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mICRDaGVtaWNhbCkgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiAkQ2hlbWljYWwpICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhY3RpdmF0ZURhdGEoaXRlbSwgb3duZXIgfHwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWFjdGl2YXRlRGF0YSh2YWx1ZSwgb3duZXIgfHwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdGl2YXRlcyBhIG5lc3RlZCBkYXRhIG9iamVjdCBpbiBhbiBvYmplY3Qgb3IgZmllbGQgXG4gKi9cbmZ1bmN0aW9uIHJlYWN0aXZhdGVEYXRhKG9iajogYW55LCBvd25lcjogYW55KSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgKG9iaiBhcyBhbnkpW3JlYWN0aXZhdGVkXSB8fCBvYmogaW5zdGFuY2VvZiAkQ2hlbWljYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlYWN0aXZhdGUob2JqLCBvd25lcik7XG59XG5cbi8qKlxuICogRGVhY3RpdmF0ZXMgYW4gb2JqZWN0LCBwcmV2ZW50aW5nIGl0IGZyb20gdHJpZ2dlcmluZyB1cGRhdGVzXG4gKiBUaGlzIGlzIGV4cG9ydGVkIGZvciBhZHZhbmNlZCB1c2FnZSBidXQgZ2VuZXJhbGx5IHNob3VsZCBiZSB1c2VkIHZpYSBDaGVtaWNhbC5kZWFjdGl2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlYWN0aXZhdGU8VCBleHRlbmRzIG9iamVjdD4oaW5zdGFuY2U6IFQpOiBUIHtcbiAgICAvLyBNYXJrIGFzIGRlYWN0aXZhdGVkXG4gICAgKGluc3RhbmNlIGFzIGFueSlbZGVhY3RpdmF0ZWRdID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIHRvIG1hcmsgYSBmaWVsZCBhcyBpbmVydCAobm9uLXJlYWN0aXZlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5lcnQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICAgICAgICAvLyBDcmVhdGUgb3IgZ2V0IHRoZSBpbmVydCBwcm9wZXJ0aWVzIHNldFxuICAgICAgICBpZiAoIXRhcmdldFtkZWFjdGl2YXRlZCBhcyBhbnldKSB7XG4gICAgICAgICAgICB0YXJnZXRbZGVhY3RpdmF0ZWQgYXMgYW55XSA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoaXMgcHJvcGVydHkgdG8gdGhlIGluZXJ0IHNldFxuICAgICAgICB0YXJnZXRbZGVhY3RpdmF0ZWQgYXMgYW55XS5hZGQocHJvcGVydHlLZXkpO1xuICAgIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIHRvIHNwZWNpZnkgYSBjdXN0b20gZXF1YWxpdHkgY29tcGFyaXNvbiBmb3IgYSBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YXRlKGNvbXBhcmVyOiAoYTogYW55LCBiOiBhbnkpID0+IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvciBnZXQgdGhlIHByb3BlcnR5IGNvbXBhcmVycyBtYXBcbiAgICAgICAgaWYgKCF0YXJnZXRbY29tcGFyZXJTeW1ib2wgYXMgYW55XSkge1xuICAgICAgICAgICAgdGFyZ2V0W2NvbXBhcmVyU3ltYm9sIGFzIGFueV0gPSBuZXcgTWFwPHN0cmluZywgKGE6IGFueSwgYjogYW55KSA9PiBib29sZWFuPigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSBjdXN0b20gY29tcGFyZXIgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgICAgdGFyZ2V0W2NvbXBhcmVyU3ltYm9sIGFzIGFueV0uc2V0KHByb3BlcnR5S2V5LCBjb21wYXJlcik7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgZm9yIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgdXNlIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvblxuICogVXNlZnVsIGZvciBhcnJheXMsIGNvbGxlY3Rpb25zLCBhbmQgY29tcGxleCBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBzdHJpbmcpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG9yIGdldCB0aGUgcHJvcGVydHkgY29tcGFyZXJzIG1hcFxuICAgICAgICBpZiAoIXRhcmdldFtjb21wYXJlclN5bWJvbCBhcyBhbnldKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29tcGFyZXJTeW1ib2wgYXMgYW55XSA9IG5ldyBNYXA8c3RyaW5nLCAoYTogYW55LCBiOiBhbnkpID0+IGJvb2xlYW4+KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYSBKU09OLWJhc2VkIGRlZXAgY29tcGFyZXIgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgICAgdGFyZ2V0W2NvbXBhcmVyU3ltYm9sIGFzIGFueV0uc2V0KHByb3BlcnR5S2V5LCAoYTogYW55LCBiOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdHJpbmdpZnkgZmFpbHMgKGNpcmN1bGFyIHJlZnMsIGV0Yy4pLCBmYWxsIGJhY2sgdG8gcmVmZXJlbmNlIGVxdWFsaXR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZvciBtZXRob2RzIHRoYXQgc2hvdWxkIHJ1biBhZnRlciBjb21wb25lbnQgcmVuZGVyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnRhaWwoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcblxuICAgICAgICAvLyBDcmVhdGUgb3IgZ2V0IHRoZSBjYXRhbHlzdHMgbWV0aG9kcyBzZXRcbiAgICAgICAgaWYgKCF0YXJnZXQuY2F0YWx5c3RNZXRob2RzKSB7XG4gICAgICAgICAgICB0YXJnZXQuY2F0YWx5c3RNZXRob2RzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhpcyBtZXRob2QgdG8gdGhlIGNhdGFseXN0cyBzZXRcbiAgICAgICAgdGFyZ2V0LmNhdGFseXN0TWV0aG9kcy5hZGQocHJvcGVydHlLZXkpO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgb3JpZ2luYWwgZGVzY3JpcHRvclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9O1xufVxuXG4vKipcbiAqIERlY29yYXRvciBmb3IgcHJvcGVydGllcyB0aGF0IHNob3VsZCBydW4gdGhlIHZhbHVlIHRocm91Z2ggYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybWVyOiAodmFsdWU6IGFueSkgPT4gYW55KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICAgICAgICAvLyBDcmVhdGUgb3IgZ2V0IHRoZSB0cmFuc2Zvcm1lcnMgbWFwXG4gICAgICAgIGlmICghdGFyZ2V0LnRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgdGFyZ2V0LnRyYW5zZm9ybWVycyA9IG5ldyBNYXA8c3RyaW5nLCAodmFsdWU6IGFueSkgPT4gYW55PigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSB0cmFuc2Zvcm1lciBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAgICB0YXJnZXQudHJhbnNmb3JtZXJzLnNldChwcm9wZXJ0eUtleSwgdHJhbnNmb3JtZXIpO1xuICAgIH07XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBiaW5kaW5nIGRlY29yYXRvcnNcbiAqL1xuaW50ZXJmYWNlIEJpbmRpbmcge1xuICAgIGNsYXNzPzogdHlwZW9mICRDaGVtaWNhbDsgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjbGFzcyB0byBiaW5kXG4gICAgb3B0aW9uYWw/OiBib29sZWFuOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGV0aGVyIGJpbmRpbmcgaXMgb3B0aW9uYWxcbiAgICBwb3NpdGlvbj86IG51bWJlcjsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBAZmlyc3QsIEBzZWNvbmQsIGV0YyAoMC1iYXNlZClcbiAgICB3aGVyZT86IChpbnN0YW5jZTogYW55KSA9PiBib29sZWFuOyAgICAgICAgIC8vIENvbmRpdGlvbmFsIHByZWRpY2F0ZVxuICAgIHByb3BlcnR5OiBzdHJpbmc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydHkgbmFtZSAoZm9yIGNvbnZlbmllbmNlKVxufVxuXG4vKipcbiAqIERlY29yYXRvciBmb3IgYmluZGluZyBhIGNoaWxkIHRvIGEgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkKENoaWxkQ2xhc3M6IGFueSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3IgYXMgYW55O1xuICAgICAgICBpZiAoIWNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXApIGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAgPSBuZXcgTWFwPHN0cmluZywgQmluZGluZz4oKTtcblxuICAgICAgICBsZXQgYmluZGluZyA9IGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAuZ2V0KHByb3BlcnR5S2V5KTtcbiAgICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5nID0geyBwcm9wZXJ0eTogcHJvcGVydHlLZXkgfTtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAuc2V0KHByb3BlcnR5S2V5LCBiaW5kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRpbmcuY2xhc3MgPSBDaGlsZENsYXNzO1xuICAgICAgICBpZiAoYmluZGluZy5vcHRpb25hbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYmluZGluZy5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZvciBwb3NpdGlvbmFsIGNoaWxkIHByb3BlcnR5IGJpbmRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3IgYXMgYW55O1xuICAgICAgICBpZiAoIWNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXApIGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAgPSBuZXcgTWFwPHN0cmluZywgQmluZGluZz4oKTtcblxuICAgICAgICBsZXQgYmluZGluZyA9IGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAuZ2V0KHByb3BlcnR5S2V5KTtcbiAgICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5nID0geyBwcm9wZXJ0eTogcHJvcGVydHlLZXkgfTtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAuc2V0KHByb3BlcnR5S2V5LCBiaW5kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRpbmcub3B0aW9uYWwgPSB0cnVlO1xuICAgIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZvciBjb25kaXRpb25hbCBjaGlsZCBwcm9wZXJ0eSBiaW5kaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aGVyZShwcmVkaWNhdGU6IChpbnN0YW5jZTogJENoZW1pY2FsKSA9PiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvciBhcyBhbnk7XG4gICAgICAgIGlmICghY29uc3RydWN0b3IuX19iaW5kaW5nc01hcCkgY29uc3RydWN0b3IuX19iaW5kaW5nc01hcCA9IG5ldyBNYXA8c3RyaW5nLCBCaW5kaW5nPigpO1xuXG4gICAgICAgIGxldCBiaW5kaW5nID0gY29uc3RydWN0b3IuX19iaW5kaW5nc01hcC5nZXQocHJvcGVydHlLZXkpO1xuICAgICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgICAgIGJpbmRpbmcgPSB7IHByb3BlcnR5OiBwcm9wZXJ0eUtleSB9O1xuICAgICAgICAgICAgY29uc3RydWN0b3IuX19iaW5kaW5nc01hcC5zZXQocHJvcGVydHlLZXksIGJpbmRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluZGluZy53aGVyZSA9IHByZWRpY2F0ZTtcbiAgICB9O1xufVxuXG4vKipcbiAqIERlY29yYXRvciBmb3IgcG9zaXRpb25hbCBjaGlsZCBwcm9wZXJ0eSBiaW5kaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3NpdGlvbihuOiBudW1iZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yIGFzIGFueTtcbiAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvci5fX2JpbmRpbmdzTWFwKSBjb25zdHJ1Y3Rvci5fX2JpbmRpbmdzTWFwID0gbmV3IE1hcDxzdHJpbmcsIEJpbmRpbmc+KCk7XG5cbiAgICAgICAgbGV0IGJpbmRpbmcgPSBjb25zdHJ1Y3Rvci5fX2JpbmRpbmdzTWFwLmdldChwcm9wZXJ0eUtleSk7XG4gICAgICAgIGlmICghYmluZGluZykge1xuICAgICAgICAgICAgYmluZGluZyA9IHsgcHJvcGVydHk6IHByb3BlcnR5S2V5IH07XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5fX2JpbmRpbmdzTWFwLnNldChwcm9wZXJ0eUtleSwgYmluZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBiaW5kaW5nLnBvc2l0aW9uID0gbiAtIDE7ICAvLyAwLWJhc2VkXG4gICAgfTtcbn1cblxuLy8gQ29udmVuY2llbmNlIGNoaWxkIGJpbmRpbmcgZGVjb3JhdG9ycyBmb3IgZGlmZmVyZW50IHBvc2l0aW9uc1xuZXhwb3J0IGNvbnN0IGZpcnN0ID0gcG9zaXRpb24oMSk7XG5leHBvcnQgY29uc3Qgc2Vjb25kID0gcG9zaXRpb24oMik7XG5leHBvcnQgY29uc3QgdGhpcmQgPSBwb3NpdGlvbigzKTtcbmV4cG9ydCBjb25zdCBmb3VydGggPSBwb3NpdGlvbig0KTtcbmV4cG9ydCBjb25zdCBmaWZ0aCA9IHBvc2l0aW9uKDUpO1xuXG4vLyBUeXBlIGRlZmluaXRpb25zIGZvciBkZWNvcmF0b3IgY29uZmlndXJhdGlvblxudHlwZSBNZW1iZXJUeXBlID0gJ21ldGhvZCcgfCAncHJvcGVydHknIHwgJ2ZpZWxkJztcbnR5cGUgRGVjb3JhdG9yQ29uZmlnID0ge1xuICAgIGJlZm9yZT86IChcbiAgICAgICAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gICAgICAgIG1lbWJlck5hbWU6IHN0cmluZyxcbiAgICAgICAgbWVtYmVyVHlwZTogTWVtYmVyVHlwZSxcbiAgICAgICAgbWV0aG9kOiBGdW5jdGlvbixcbiAgICAgICAgYXJnczogYW55W11cbiAgICApID0+IFtGdW5jdGlvbiwgYW55W11dIHwgdW5kZWZpbmVkO1xuICAgIGFmdGVyPzogKFxuICAgICAgICBjbGFzc05hbWU6IHN0cmluZyxcbiAgICAgICAgbWVtYmVyTmFtZTogc3RyaW5nLFxuICAgICAgICBtZW1iZXJUeXBlOiBNZW1iZXJUeXBlLFxuICAgICAgICBtZXRob2Q6IEZ1bmN0aW9uLFxuICAgICAgICBhcmdzOiBhbnlbXSxcbiAgICAgICAgcmVzdWx0OiBhbnlcbiAgICApID0+IGFueSB8IHVuZGVmaW5lZDtcbiAgICBlcnJvcj86IChcbiAgICAgICAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gICAgICAgIG1lbWJlck5hbWU6IHN0cmluZyxcbiAgICAgICAgbWVtYmVyVHlwZTogTWVtYmVyVHlwZSxcbiAgICAgICAgbWV0aG9kOiBGdW5jdGlvbixcbiAgICAgICAgYXJnczogYW55W10sXG4gICAgICAgIGVycm9yOiBhbnlcbiAgICApID0+IGFueSB8IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRGVjb3JhdGVzIGFuIG9iamVjdCdzIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgd2l0aCBpbnRlcmNlcHRvcnNcbiAqL1xuZnVuY3Rpb24gZGVjb3JhdGU8VCBleHRlbmRzIG9iamVjdD4oaW5zdGFuY2U6IFQsIGNvbmZpZzogRGVjb3JhdG9yQ29uZmlnKTogVCB7XG4gICAgLy8gU2tpcCBpZiBhbHJlYWR5IGRlY29yYXRlZFxuICAgIGlmICgoaW5zdGFuY2UgYXMgYW55KVtyZWFjdGl2YXRlZF0pIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzTmFtZTogc3RyaW5nID0gaW5zdGFuY2U/LmNvbnN0cnVjdG9yPy5uYW1lID8/IFwiPFVOS05PV04+XCI7XG5cbiAgICAvLyBTdG9yZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAoaW5zdGFuY2UgYXMgYW55KVtiYWNraW5nRmllbGRzXSA9IHt9O1xuICAgIChpbnN0YW5jZSBhcyBhbnkpW29yaWdpbmFsVmFsdWVzXSA9IHt9O1xuXG4gICAgLy8gUHJvY2VzcyBwcm9wZXJ0aWVzIGFuZCBmaWVsZHNcbiAgICBkZWNvcmF0ZVByb3BlcnRpZXMoaW5zdGFuY2UsIGNsYXNzTmFtZSwgY29uZmlnKTtcblxuICAgIC8vIE1hcmsgYXMgcmVhY3RpZmllZFxuICAgIChpbnN0YW5jZSBhcyBhbnkpW3JlYWN0aXZhdGVkXSA9IHRydWU7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8qKlxuICogRGVjb3JhdGVzIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IHdpdGggaW50ZXJjZXB0b3JzXG4gKi9cbmZ1bmN0aW9uIGRlY29yYXRlUHJvcGVydGllcyhpbnN0YW5jZTogYW55LCBjbGFzc05hbWU6IHN0cmluZywgY29uZmlnOiBEZWNvcmF0b3JDb25maWcpOiB2b2lkIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2V0QWxsUHJvcGVydGllcyhpbnN0YW5jZSk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIFNraXAgaW50ZXJuYWwgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB3ZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InIHx8XG4gICAgICAgICAgICBrZXkgPT09IFN0cmluZyhyZWFjdGl2YXRlZCkgfHxcbiAgICAgICAgICAgIGtleSA9PT0gU3RyaW5nKGJhY2tpbmdGaWVsZHMpIHx8XG4gICAgICAgICAgICBrZXkgPT09IFN0cmluZyhvcmlnaW5hbFZhbHVlcykgfHxcbiAgICAgICAgICAgIGtleSA9PT0gJ3N0YXRlJyB8fCBrZXkgPT09ICdwcm9wcycgfHxcbiAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZVtrZXldID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAkQ2hlbWljYWwucHJvdG90eXBlLmhhc093blByb3BlcnR5KGtleSkgfHwgICAgLy8gU2tpcCBDaGVtaWNhbCBiYXNlIGNsYXNzIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGluc3RhbmNlW2tleV0gaW5zdGFuY2VvZiAkQ2hlbWljYWwpIHsgICAgICAgICAvLyBTa2lwIENoZW1pY2FsIGluc3RhbmNlc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFscmVhZHkgYW4gYWNjZXNzb3IgcHJvcGVydHlcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5zdGFuY2UsIGtleSkgfHxcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3RhbmNlKSwga2V5KTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci5nZXQgfHwgZGVzY3JpcHRvci5zZXQpKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYWNjZXNzb3IgcHJvcGVydHlcbiAgICAgICAgICAgIGRlY29yYXRlQWNjZXNzb3JQcm9wZXJ0eShpbnN0YW5jZSwga2V5LCBkZXNjcmlwdG9yLCBjbGFzc05hbWUsIGNvbmZpZyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSByZWd1bGFyIGRhdGEgcHJvcGVydHlcbiAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgaW5zdGFuY2VbYmFja2luZ0ZpZWxkc11ba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbiAgICAgICAgLy8gUmVwbGFjZSB3aXRoIGdldHRlci9zZXR0ZXIgZm9yIHJlZ3VsYXIgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIGtleSwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2JhY2tpbmdGaWVsZHNdW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyUmVzdWx0ID0gY29uZmlnLmFmdGVyKGNsYXNzTmFtZSwga2V5LCAncHJvcGVydHknLCAoKSA9PiB7IH0sIFtdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZnRlclJlc3VsdCA/PyB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbYmFja2luZ0ZpZWxkc11ba2V5XTtcblxuICAgICAgICAgICAgICAgIC8vIFNraXAgdXBkYXRlIGlmIHZhbHVlcyBhcmUgZXF1YWxcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgY3VzdG9tIGNvbXBhcmVyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzQ3VzdG9tQ29tcGFyZXIgPSBwcm90byAmJlxuICAgICAgICAgICAgICAgICAgICBwcm90b1tjb21wYXJlclN5bWJvbCBhcyBhbnldICYmXG4gICAgICAgICAgICAgICAgICAgIHByb3RvW2NvbXBhcmVyU3ltYm9sIGFzIGFueV0uaGFzKGtleSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQ3VzdG9tQ29tcGFyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tQ29tcGFyZXIgPSBwcm90b1tjb21wYXJlclN5bWJvbCBhcyBhbnldLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQ29tcGFyZXIob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTa2lwIHVwZGF0ZSBpZiBjdXN0b20gY29tcGFyZXIgc2F5cyB0aGV5J3JlIGVxdWFsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVUb1NldCA9IG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgYmVmb3JlIGxvZ2ljIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZVJlc3VsdCA9IGNvbmZpZy5iZWZvcmUoY2xhc3NOYW1lLCBrZXksICdmaWVsZCcsICgpID0+IHsgfSwgW25ld1ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVSZXN1bHQgJiYgYmVmb3JlUmVzdWx0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVRvU2V0ID0gYmVmb3JlUmVzdWx0WzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZyb3plbi9zZWFsZWQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVRvU2V0ICYmIHR5cGVvZiB2YWx1ZVRvU2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHJlYWN0aWZpY2F0aW9uIGZvciBmcm96ZW4vc2VhbGVkIG9iamVjdHMgYW5kIENoZW1pY2FsIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZVRvU2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5pc1NlYWxlZCh2YWx1ZVRvU2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZVRvU2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgISh2YWx1ZVRvU2V0IGluc3RhbmNlb2YgJENoZW1pY2FsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVlcCByZWFjdGlmeSBjb21wbGV4IG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZVRvU2V0KSAmJiAhKHZhbHVlVG9TZXQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0aXZhdGVEYXRhKHZhbHVlVG9TZXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzW2JhY2tpbmdGaWVsZHNdW2tleV0gPSB2YWx1ZVRvU2V0O1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgYWZ0ZXIgbG9naWNcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5hZnRlcihjbGFzc05hbWUsIGtleSwgJ2ZpZWxkJywgKCkgPT4geyB9LCBbdmFsdWVUb1NldF0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIERlY29yYXRlcyBhbiBhY2Nlc3NvciBwcm9wZXJ0eSAoZ2V0dGVyL3NldHRlcilcbiAqL1xuZnVuY3Rpb24gZGVjb3JhdGVBY2Nlc3NvclByb3BlcnR5KFxuICAgIGluc3RhbmNlOiBhbnksXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGNsYXNzTmFtZTogc3RyaW5nLFxuICAgIGNvbmZpZzogRGVjb3JhdG9yQ29uZmlnXG4pOiB2b2lkIHtcbiAgICBjb25zdCBvcmlnaW5hbEdldCA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgIGNvbnN0IG9yaWdpbmFsU2V0ID0gZGVzY3JpcHRvci5zZXQ7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIG9yaWdpbmFsIGdldHRlciBiZWhhdmlvclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvcmlnaW5hbEdldD8uY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5hZnRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyUmVzdWx0ID0gY29uZmlnLmFmdGVyKGNsYXNzTmFtZSwga2V5LCAncHJvcGVydHknLCAoKSA9PiB7IH0sIFtdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyUmVzdWx0ID8/IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIW9yaWdpbmFsU2V0KSByZXR1cm47IC8vIFJlYWQtb25seSBwcm9wZXJ0eVxuXG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9yaWdpbmFsR2V0Py5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBTa2lwIHVwZGF0ZSBpZiB2YWx1ZXMgYXJlIGVxdWFsXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3VzdG9tIGNvbXBhcmVyXG4gICAgICAgICAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0N1c3RvbUNvbXBhcmVyID0gcHJvdG8gJiZcbiAgICAgICAgICAgICAgICBwcm90b1tjb21wYXJlclN5bWJvbCBhcyBhbnldICYmXG4gICAgICAgICAgICAgICAgcHJvdG9bY29tcGFyZXJTeW1ib2wgYXMgYW55XS5oYXMoa2V5KTtcblxuICAgICAgICAgICAgaWYgKGhhc0N1c3RvbUNvbXBhcmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tQ29tcGFyZXIgPSBwcm90b1tjb21wYXJlclN5bWJvbCBhcyBhbnldLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21Db21wYXJlcihvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU2tpcCB1cGRhdGUgaWYgY3VzdG9tIGNvbXBhcmVyIHNheXMgdGhleSdyZSBlcXVhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCBvcmlnaW5hbCBzZXR0ZXJcbiAgICAgICAgICAgIG9yaWdpbmFsU2V0LmNhbGwodGhpcywgbmV3VmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBhZnRlciBsb2dpYyB0byB0cmlnZ2VyIHVwZGF0ZXNcbiAgICAgICAgICAgIGlmIChjb25maWcuYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuYWZ0ZXIoY2xhc3NOYW1lLCBrZXksICdmaWVsZCcsICgpID0+IHsgfSwgW25ld1ZhbHVlXSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9iamVjdCBpcyBhIGJhc2Ugb2JqZWN0IG1ldGhvZFxuICovXG5mdW5jdGlvbiBpc0Jhc2VPYmplY3RNZXRob2QobWV0aG9kTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChPYmplY3QucHJvdG90eXBlLCBtZXRob2ROYW1lKTtcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCBtZXRob2RzIGZyb20gYW4gb2JqZWN0IGFuZCBpdHMgcHJvdG90eXBlIGNoYWluXG4gKi9cbmZ1bmN0aW9uIGdldEFsbE1ldGhvZHMob2JqOiBhbnkpOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uIH0ge1xuICAgIGNvbnN0IG1ldGhvZHM6IHsgW2tleTogc3RyaW5nXTogRnVuY3Rpb24gfSA9IHt9O1xuICAgIGxldCBwcm90byA9IG9iajtcblxuICAgIHdoaWxlIChwcm90byAmJiBwcm90byAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm90bykge1xuICAgICAgICAgICAgaWYgKG1ldGhvZHNba2V5XSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIHByb3RvW2tleV0gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICFrZXkuc3RhcnRzV2l0aChcIl9cIikgJiYgLy8gU2tpcCBwcml2YXRlIG1ldGhvZHNcbiAgICAgICAgICAgICAgICAhaXNCYXNlT2JqZWN0TWV0aG9kKGtleSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1ldGhvZHNba2V5XSA9IHByb3RvW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8gPSBwcm90by5fX3Byb3RvX187XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZHM7XG59XG5cbi8qKlxuICogR2V0cyBhbGwgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRBbGxQcm9wZXJ0aWVzKG9iajogYW55KTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIC8vIEdldCBvd24gcHJvcGVydGllc1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgcHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgfSk7XG5cbiAgICAvLyBHZXQgcHJvcGVydGllcyBmcm9tIHByb3RvdHlwZSBjaGFpblxuICAgIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIHdoaWxlIChwcm90byAmJiBwcm90byAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIGlmICghcHJvcC5zdGFydHNXaXRoKCdfJykgJiYgcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5mcm9tKHByb3BlcnRpZXMpO1xufSJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwicmVhY3RpdmF0ZWQiLCJTeW1ib2wiLCJiYWNraW5nRmllbGRzIiwib3JpZ2luYWxWYWx1ZXMiLCJkZWFjdGl2YXRlZCIsImNvbXBhcmVyU3ltYm9sIiwiY29tcG9uZW50VXBkYXRlcnMiLCJXZWFrTWFwIiwiJENoZW1pY2FsIiwidmlldyIsImVsZW1lbnRzIiwiY3JlYXRlQ29tcG9uZW50Iiwic2VsZiIsIkNoZW1pY2FsQ29tcG9uZW50IiwicHJvcHMiLCJpbnN0YW5jZSIsImNyZWF0ZUluc3RhbmNlIiwiZm9yY2VVcGRhdGUiLCJzZXR1cEluc3RhbmNlIiwiY2xlYW51cEluc3RhbmNlIiwicHJvY2Vzc0NoaWxkcmVuIiwiaXNDaGVtaWNhbCIsIk9iamVjdCIsImNyZWF0ZSIsImNoaWxkcmVuIiwiYXBwbHlQcm9wcyIsInNldHVwUmVhY3Rpdml0eSIsImhhbmRsZVBhcmVudEJpbmRpbmciLCJydW5DYXRhbHlzdE1ldGhvZHMiLCJkZWxldGUiLCJwYXJlbnQiLCJ1bnJlZ2lzdGVyRnJvbVBhcmVudCIsImtleSIsImhhc093blByb3BlcnR5Iiwic2V0UHJvcCIsInZhbHVlIiwiY29tcG9uZW50S2V5IiwiU3RyaW5nIiwidHJhbnNmb3JtZXJzIiwicHJvdG90eXBlIiwiaGFzIiwidHJhbnNmb3JtZXIiLCJnZXQiLCJzZXQiLCJkZWNvcmF0ZSIsImFmdGVyIiwiY2xhc3NOYW1lIiwibWVtYmVyTmFtZSIsIm1lbWJlclR5cGUiLCJtZXRob2QiLCJhcmdzIiwicmVzdWx0IiwidXBkYXRlRm4iLCJjb25zb2xlIiwibG9nIiwiX19wYXJlbnRJbnN0YW5jZSIsInJlZ2lzdGVyV2l0aFBhcmVudCIsImNoaWxkIiwidHJhY2tDaGlsZCIsImFwcGx5QmluZGluZyIsImluY2x1ZGVzIiwicHVzaCIsInVudHJhY2tDaGlsZCIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImJpbmRpbmdzIiwiZ2V0QmluZGluZ3MiLCJjaGlsZFBvc2l0aW9uQ291bnRzIiwiTWFwIiwiYmluZGluZyIsInByb3BlcnR5IiwibWF0Y2hlc0JpbmRpbmciLCJiaW5kQ2hpbGQiLCJjbGFzcyIsInBvc2l0aW9uIiwidW5kZWZpbmVkIiwiY291bnQiLCJ3aGVyZSIsInByb3AiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmJpbmRDaGlsZCIsIm1ldGhvZHMiLCJjYXRhbHlzdE1ldGhvZHMiLCJtZXRob2ROYW1lIiwibW9kaWZpZWRDaGlsZHJlbiIsIm1vZGlmeUNoaWxkcmVuIiwiY2hpbGRyZW5BcnJheSIsIkNoaWxkcmVuIiwidG9BcnJheSIsIm1hcCIsImlzVmFsaWRFbGVtZW50IiwidHlwZSIsImNsb25lRWxlbWVudCIsImNyZWF0ZUZyYWdtZW50IiwiYWJvdmUiLCJtYWluIiwiYmVsb3ciLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsIl9tZXJnZWRCaW5kaW5ncyIsIm1lcmdlZE1hcCIsInByb3RvIiwiX19iaW5kaW5nc01hcCIsImZvckVhY2giLCJnZXRQcm90b3R5cGVPZiIsIndhcm4iLCJzb3J0IiwiYSIsImIiLCJyZWFjdGl2YXRlIiwib3duZXIiLCJ0cmlnZ2VyVXBkYXRlIiwic3RhcnRzV2l0aCIsIkRhdGUiLCJpdGVtIiwicmVhY3RpdmF0ZURhdGEiLCJvYmoiLCJkZWFjdGl2YXRlIiwiaW5lcnQiLCJ0YXJnZXQiLCJwcm9wZXJ0eUtleSIsIlNldCIsImFkZCIsImVxdWF0ZSIsImNvbXBhcmVyIiwiZHluYW1pYyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiZW50YWlsIiwiZGVzY3JpcHRvciIsIm9yaWdpbmFsTWV0aG9kIiwidHJhbnNmb3JtIiwiQ2hpbGRDbGFzcyIsIm9wdGlvbmFsIiwicHJlZGljYXRlIiwibiIsImZpcnN0Iiwic2Vjb25kIiwidGhpcmQiLCJmb3VydGgiLCJmaWZ0aCIsImNvbmZpZyIsIm5hbWUiLCJkZWNvcmF0ZVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwiZ2V0QWxsUHJvcGVydGllcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlY29yYXRlQWNjZXNzb3JQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiYWZ0ZXJSZXN1bHQiLCJuZXdWYWx1ZSIsIm9sZFZhbHVlIiwiaGFzQ3VzdG9tQ29tcGFyZXIiLCJjdXN0b21Db21wYXJlciIsInZhbHVlVG9TZXQiLCJiZWZvcmUiLCJiZWZvcmVSZXN1bHQiLCJpc0Zyb3plbiIsImlzU2VhbGVkIiwiaXNFeHRlbnNpYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIm9yaWdpbmFsR2V0Iiwib3JpZ2luYWxTZXQiLCJjYWxsIiwiaXNCYXNlT2JqZWN0TWV0aG9kIiwiZ2V0QWxsTWV0aG9kcyIsIl9fcHJvdG9fXyIsImdldE93blByb3BlcnR5TmFtZXMiLCJmcm9tIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/chemistry.ts\n"));

/***/ })

});