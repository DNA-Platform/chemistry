/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/tests/property-binding/page"],{

/***/ "(app-pages-browser)/./app/tests/property-binding/page.tsx":
/*!*********************************************!*\
  !*** ./app/tests/property-binding/page.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BasicBindingTest)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_ts_decorate */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _chemistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/chemistry */ \"(app-pages-browser)/./src/chemistry.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\nclass $Child extends _chemistry__WEBPACK_IMPORTED_MODULE_1__.$Chemical {\n    view() {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                border: '2px solid green',\n                padding: '10px',\n                borderRadius: '4px'\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                    children: \"Child Component\"\n                }, void 0, false, {\n                    fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                    lineNumber: 10,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: [\n                        \"Name: \",\n                        this.$name\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                    lineNumber: 11,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n            lineNumber: 9,\n            columnNumber: 13\n        }, this);\n    }\n    constructor(...args){\n        super(...args), this.$name = 'Default Child';\n    }\n}\nclass $Parent extends _chemistry__WEBPACK_IMPORTED_MODULE_1__.$Chemical {\n    view() {\n        var _this_child, _this_child1;\n        console.log('Parent.view() - this.child:', this.child);\n        console.log('Parent.view() - this.children:', this.children);\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                border: '2px solid blue',\n                padding: '20px',\n                borderRadius: '8px'\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                    children: \"Parent Component\"\n                }, void 0, false, {\n                    fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                    lineNumber: 26,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        marginBottom: '10px'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"✓ Child bound: \",\n                                this.child ? 'YES' : 'NO'\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                            lineNumber: 28,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"✓ Child name: \",\n                                ((_this_child = this.child) === null || _this_child === void 0 ? void 0 : _this_child.$name) || 'N/A'\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                            lineNumber: 29,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                    lineNumber: 27,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        marginLeft: '20px',\n                        marginTop: '20px'\n                    },\n                    children: (_this_child1 = this.child) === null || _this_child1 === void 0 ? void 0 : _this_child1.view()\n                }, void 0, false, {\n                    fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                    lineNumber: 31,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n            lineNumber: 25,\n            columnNumber: 13\n        }, this);\n    }\n}\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_2__.__decorate)([\n    (0,_chemistry__WEBPACK_IMPORTED_MODULE_1__.child)($Child)\n], $Parent.prototype, \"child\", void 0);\nfunction BasicBindingTest() {\n    const Parent = new $Parent().Component; // Access property, not method\n    const Child = new $Child().Component; // Access property, not method\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            padding: '40px',\n            fontFamily: 'system-ui'\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                children: \"Basic Binding Test\"\n            }, void 0, false, {\n                fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                lineNumber: 45,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                style: {\n                    color: '#666',\n                    marginBottom: '30px'\n                },\n                children: \"Tests that a child component is properly bound to its parent using the @child decorator.\"\n            }, void 0, false, {\n                fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                lineNumber: 46,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: '20px'\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        children: \"Expected Results:\"\n                    }, void 0, false, {\n                        fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: 'Parent should show \"Child bound: YES\"'\n                            }, void 0, false, {\n                                fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                                lineNumber: 53,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: 'Parent should show \"Child name: Test Child\"'\n                            }, void 0, false, {\n                                fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                                lineNumber: 54,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: \"Child component should be rendered inside parent\"\n                            }, void 0, false, {\n                                fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                                lineNumber: 55,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                        lineNumber: 52,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                lineNumber: 50,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    background: '#f5f5f5',\n                    padding: '20px',\n                    borderRadius: '8px'\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Parent, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Child, {\n                        name: \"Test Child\"\n                    }, void 0, false, {\n                        fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                        lineNumber: 61,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                    lineNumber: 60,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                lineNumber: 59,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginTop: '30px'\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        children: \"Test Status:\"\n                    }, void 0, false, {\n                        fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            padding: '10px',\n                            background: '#d4edda',\n                            color: '#155724',\n                            border: '1px solid #c3e6cb',\n                            borderRadius: '4px'\n                        },\n                        children: \"✓ If you see the child component inside the parent with correct name, the test passes\"\n                    }, void 0, false, {\n                        fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                        lineNumber: 67,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n                lineNumber: 65,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/doug/repos/dna-platform/chemistry/app/tests/property-binding/page.tsx\",\n        lineNumber: 44,\n        columnNumber: 9\n    }, this);\n}\n_c = BasicBindingTest;\nvar _c;\n$RefreshReg$(_c, \"BasicBindingTest\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC90ZXN0cy9wcm9wZXJ0eS1iaW5kaW5nL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUMrQztBQUUvQyxNQUFNRSxlQUFlRixpREFBU0E7SUFHMUJHLE9BQU87UUFDSCxxQkFDSSw4REFBQ0M7WUFBSUMsT0FBTztnQkFBRUMsUUFBUTtnQkFBbUJDLFNBQVM7Z0JBQVFDLGNBQWM7WUFBTTs7OEJBQzFFLDhEQUFDQzs4QkFBRzs7Ozs7OzhCQUNKLDhEQUFDQzs7d0JBQUU7d0JBQU8sSUFBSSxDQUFDQyxLQUFLOzs7Ozs7Ozs7Ozs7O0lBR2hDOztRQVZKLHFCQUNJQSxRQUFnQjs7QUFVcEI7QUFFQSxNQUFNQyxnQkFBZ0JaLGlEQUFTQTtJQUkzQkcsT0FBTztZQVE2QixhQUduQjtRQVZiVSxRQUFRQyxHQUFHLENBQUMsK0JBQStCLElBQUksQ0FBQ2IsS0FBSztRQUNyRFksUUFBUUMsR0FBRyxDQUFDLGtDQUFrQyxJQUFJLENBQUNDLFFBQVE7UUFDM0QscUJBQ0ksOERBQUNYO1lBQUlDLE9BQU87Z0JBQUVDLFFBQVE7Z0JBQWtCQyxTQUFTO2dCQUFRQyxjQUFjO1lBQU07OzhCQUN6RSw4REFBQ1E7OEJBQUc7Ozs7Ozs4QkFDSiw4REFBQ1o7b0JBQUlDLE9BQU87d0JBQUVZLGNBQWM7b0JBQU87O3NDQUMvQiw4REFBQ2I7O2dDQUFJO2dDQUFnQixJQUFJLENBQUNILEtBQUssR0FBRyxRQUFROzs7Ozs7O3NDQUMxQyw4REFBQ0c7O2dDQUFJO2dDQUFlLG9CQUFJLENBQUNILEtBQUssY0FBViw4Q0FBWVUsS0FBSyxLQUFJOzs7Ozs7Ozs7Ozs7OzhCQUU3Qyw4REFBQ1A7b0JBQUlDLE9BQU87d0JBQUVhLFlBQVk7d0JBQVFDLFdBQVc7b0JBQU87K0JBQy9DLG1CQUFJLENBQUNsQixLQUFLLGNBQVYsZ0RBQVlFLElBQUk7Ozs7Ozs7Ozs7OztJQUlqQztBQUNKOzs7O0FBRWUsU0FBU2lCO0lBQ3BCLE1BQU1DLFNBQVMsSUFBSVQsVUFBVVUsU0FBUyxFQUFHLDhCQUE4QjtJQUN2RSxNQUFNQyxRQUFRLElBQUlyQixTQUFTb0IsU0FBUyxFQUFLLDhCQUE4QjtJQUV2RSxxQkFDSSw4REFBQ2xCO1FBQUlDLE9BQU87WUFBRUUsU0FBUztZQUFRaUIsWUFBWTtRQUFZOzswQkFDbkQsOERBQUNDOzBCQUFHOzs7Ozs7MEJBQ0osOERBQUNmO2dCQUFFTCxPQUFPO29CQUFFcUIsT0FBTztvQkFBUVQsY0FBYztnQkFBTzswQkFBRzs7Ozs7OzBCQUluRCw4REFBQ2I7Z0JBQUlDLE9BQU87b0JBQUVZLGNBQWM7Z0JBQU87O2tDQUMvQiw4REFBQ0Q7a0NBQUc7Ozs7OztrQ0FDSiw4REFBQ1c7OzBDQUNHLDhEQUFDQzswQ0FBRzs7Ozs7OzBDQUNKLDhEQUFDQTswQ0FBRzs7Ozs7OzBDQUNKLDhEQUFDQTswQ0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUlaLDhEQUFDeEI7Z0JBQUlDLE9BQU87b0JBQUV3QixZQUFZO29CQUFXdEIsU0FBUztvQkFBUUMsY0FBYztnQkFBTTswQkFDdEUsNEVBQUNhOzhCQUNHLDRFQUFDRTt3QkFBTU8sTUFBSzs7Ozs7Ozs7Ozs7Ozs7OzswQkFJcEIsOERBQUMxQjtnQkFBSUMsT0FBTztvQkFBRWMsV0FBVztnQkFBTzs7a0NBQzVCLDhEQUFDSDtrQ0FBRzs7Ozs7O2tDQUNKLDhEQUFDWjt3QkFBSUMsT0FBTzs0QkFDUkUsU0FBUzs0QkFDVHNCLFlBQVk7NEJBQ1pILE9BQU87NEJBQ1BwQixRQUFROzRCQUNSRSxjQUFjO3dCQUNsQjtrQ0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTW5CO0tBeEN3QlkiLCJzb3VyY2VzIjpbIi9ob21lL2RvdWcvcmVwb3MvZG5hLXBsYXRmb3JtL2NoZW1pc3RyeS9hcHAvdGVzdHMvcHJvcGVydHktYmluZGluZy9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCB7ICRDaGVtaWNhbCwgY2hpbGQgfSBmcm9tICdAL2NoZW1pc3RyeSc7XG5cbmNsYXNzICRDaGlsZCBleHRlbmRzICRDaGVtaWNhbCB7XG4gICAgJG5hbWU6IHN0cmluZyA9ICdEZWZhdWx0IENoaWxkJztcbiAgICBcbiAgICB2aWV3KCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBib3JkZXI6ICcycHggc29saWQgZ3JlZW4nLCBwYWRkaW5nOiAnMTBweCcsIGJvcmRlclJhZGl1czogJzRweCcgfX0+XG4gICAgICAgICAgICAgICAgPGg0PkNoaWxkIENvbXBvbmVudDwvaDQ+XG4gICAgICAgICAgICAgICAgPHA+TmFtZToge3RoaXMuJG5hbWV9PC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5jbGFzcyAkUGFyZW50IGV4dGVuZHMgJENoZW1pY2FsIHtcbiAgICBAY2hpbGQoJENoaWxkKVxuICAgIGNoaWxkITogJENoaWxkO1xuICAgIFxuICAgIHZpZXcoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQYXJlbnQudmlldygpIC0gdGhpcy5jaGlsZDonLCB0aGlzLmNoaWxkKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1BhcmVudC52aWV3KCkgLSB0aGlzLmNoaWxkcmVuOicsIHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBib3JkZXI6ICcycHggc29saWQgYmx1ZScsIHBhZGRpbmc6ICcyMHB4JywgYm9yZGVyUmFkaXVzOiAnOHB4JyB9fT5cbiAgICAgICAgICAgICAgICA8aDM+UGFyZW50IENvbXBvbmVudDwvaDM+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Cb3R0b206ICcxMHB4JyB9fT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj7inJMgQ2hpbGQgYm91bmQ6IHt0aGlzLmNoaWxkID8gJ1lFUycgOiAnTk8nfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2PuKckyBDaGlsZCBuYW1lOiB7dGhpcy5jaGlsZD8uJG5hbWUgfHwgJ04vQSd9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5MZWZ0OiAnMjBweCcsIG1hcmdpblRvcDogJzIwcHgnIH19PlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5jaGlsZD8udmlldygpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYXNpY0JpbmRpbmdUZXN0KCkge1xuICAgIGNvbnN0IFBhcmVudCA9IG5ldyAkUGFyZW50KCkuQ29tcG9uZW50OyAgLy8gQWNjZXNzIHByb3BlcnR5LCBub3QgbWV0aG9kXG4gICAgY29uc3QgQ2hpbGQgPSBuZXcgJENoaWxkKCkuQ29tcG9uZW50OyAgICAvLyBBY2Nlc3MgcHJvcGVydHksIG5vdCBtZXRob2RcbiAgICBcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICc0MHB4JywgZm9udEZhbWlseTogJ3N5c3RlbS11aScgfX0+XG4gICAgICAgICAgICA8aDE+QmFzaWMgQmluZGluZyBUZXN0PC9oMT5cbiAgICAgICAgICAgIDxwIHN0eWxlPXt7IGNvbG9yOiAnIzY2NicsIG1hcmdpbkJvdHRvbTogJzMwcHgnIH19PlxuICAgICAgICAgICAgICAgIFRlc3RzIHRoYXQgYSBjaGlsZCBjb21wb25lbnQgaXMgcHJvcGVybHkgYm91bmQgdG8gaXRzIHBhcmVudCB1c2luZyB0aGUgQGNoaWxkIGRlY29yYXRvci5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Cb3R0b206ICcyMHB4JyB9fT5cbiAgICAgICAgICAgICAgICA8aDM+RXhwZWN0ZWQgUmVzdWx0czo8L2gzPlxuICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgPGxpPlBhcmVudCBzaG91bGQgc2hvdyBcIkNoaWxkIGJvdW5kOiBZRVNcIjwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDxsaT5QYXJlbnQgc2hvdWxkIHNob3cgXCJDaGlsZCBuYW1lOiBUZXN0IENoaWxkXCI8L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+Q2hpbGQgY29tcG9uZW50IHNob3VsZCBiZSByZW5kZXJlZCBpbnNpZGUgcGFyZW50PC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgYmFja2dyb3VuZDogJyNmNWY1ZjUnLCBwYWRkaW5nOiAnMjBweCcsIGJvcmRlclJhZGl1czogJzhweCcgfX0+XG4gICAgICAgICAgICAgICAgPFBhcmVudD5cbiAgICAgICAgICAgICAgICAgICAgPENoaWxkIG5hbWU9XCJUZXN0IENoaWxkXCIgLz5cbiAgICAgICAgICAgICAgICA8L1BhcmVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpblRvcDogJzMwcHgnIH19PlxuICAgICAgICAgICAgICAgIDxoMz5UZXN0IFN0YXR1czo8L2gzPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcxMHB4JywgXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZDRlZGRhJyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMTU1NzI0JyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNjM2U2Y2InLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnXG4gICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgIOKckyBJZiB5b3Ugc2VlIHRoZSBjaGlsZCBjb21wb25lbnQgaW5zaWRlIHRoZSBwYXJlbnQgd2l0aCBjb3JyZWN0IG5hbWUsIHRoZSB0ZXN0IHBhc3Nlc1xuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59Il0sIm5hbWVzIjpbIiRDaGVtaWNhbCIsImNoaWxkIiwiJENoaWxkIiwidmlldyIsImRpdiIsInN0eWxlIiwiYm9yZGVyIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsImg0IiwicCIsIiRuYW1lIiwiJFBhcmVudCIsImNvbnNvbGUiLCJsb2ciLCJjaGlsZHJlbiIsImgzIiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsIkJhc2ljQmluZGluZ1Rlc3QiLCJQYXJlbnQiLCJDb21wb25lbnQiLCJDaGlsZCIsImZvbnRGYW1pbHkiLCJoMSIsImNvbG9yIiwidWwiLCJsaSIsImJhY2tncm91bmQiLCJuYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/tests/property-binding/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fdoug%2Frepos%2Fdna-platform%2Fchemistry%2Fapp%2Ftests%2Fproperty-binding%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fdoug%2Frepos%2Fdna-platform%2Fchemistry%2Fapp%2Ftests%2Fproperty-binding%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/tests/property-binding/page.tsx */ \"(app-pages-browser)/./app/tests/property-binding/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRmRvdWclMkZyZXBvcyUyRmRuYS1wbGF0Zm9ybSUyRmNoZW1pc3RyeSUyRmFwcCUyRnRlc3RzJTJGcHJvcGVydHktYmluZGluZyUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsb01BQWdIIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9kb3VnL3JlcG9zL2RuYS1wbGF0Zm9ybS9jaGVtaXN0cnkvYXBwL3Rlc3RzL3Byb3BlcnR5LWJpbmRpbmcvcGFnZS50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fdoug%2Frepos%2Fdna-platform%2Fchemistry%2Fapp%2Ftests%2Fproperty-binding%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL2hvbWUvZG91Zy9yZXBvcy9kbmEtcGxhdGZvcm0vY2hlbWlzdHJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGRlYnVnU3RhY2ssXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgbm9kZS5fc3RvcmUgJiZcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9ob21lL2RvdWcvcmVwb3MvZG5hLXBsYXRmb3JtL2NoZW1pc3RyeS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs":
/*!******************************************!*\
  !*** ./node_modules/tslib/tslib.es6.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),\n/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __propKey: () => (/* binding */ __propKey),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),\n/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),\n/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nfunction __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDakYsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFTztBQUNQO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTs7QUFFTztBQUNQLGtDQUFrQztBQUNsQzs7QUFFTztBQUNQLHVCQUF1Qix1RkFBdUY7QUFDOUc7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsOENBQThDLHlGQUF5RjtBQUN2SSw4REFBOEQsMkNBQTJDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBLDRDQUE0Qyx5RUFBeUU7QUFDckg7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1AsMEJBQTBCLCtEQUErRCxpQkFBaUI7QUFDMUc7QUFDQSxrQ0FBa0MsTUFBTSwrQkFBK0IsWUFBWTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFNBQVMsZ0JBQWdCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDIiwic291cmNlcyI6WyIvaG9tZS9kb3VnL3JlcG9zL2RuYS1wbGF0Zm9ybS9jaGVtaXN0cnkvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbnZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgYXIgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgIHJldHVybiBhcjtcbiAgfTtcbiAgcmV0dXJuIG93bktleXMobyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgIGlmIChhc3luYykgaW5uZXIgPSBkaXNwb3NlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgaWYgKGlubmVyKSBkaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRyeSB7IGlubmVyLmNhbGwodGhpcyk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyB9IH07XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIHZhciByLCBzID0gMDtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAociA9IGVudi5zdGFjay5wb3AoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyLmFzeW5jICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgZW52LnN0YWNrLnB1c2gociksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XG4gICAgICAgIGlmIChyLmRpc3Bvc2UpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gci5kaXNwb3NlLmNhbGwoci52YWx1ZSk7XG4gICAgICAgICAgaWYgKHIuYXN5bmMpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgfD0gMTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzID09PSAxKSByZXR1cm4gZW52Lmhhc0Vycm9yID8gUHJvbWlzZS5yZWplY3QoZW52LmVycm9yKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24ocGF0aCwgcHJlc2VydmVKc3gpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiICYmIC9eXFwuXFwuP1xcLy8udGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwuKHRzeCkkfCgoPzpcXC5kKT8pKCg/OlxcLlteLi9dKz8pPylcXC4oW2NtXT8pdHMkL2ksIGZ1bmN0aW9uIChtLCB0c3gsIGQsIGV4dCwgY20pIHtcbiAgICAgICAgICByZXR1cm4gdHN4ID8gcHJlc2VydmVKc3ggPyBcIi5qc3hcIiA6IFwiLmpzXCIgOiBkICYmICghZXh0IHx8ICFjbSkgPyBtIDogKGQgKyBleHQgKyBcIi5cIiArIGNtLnRvTG93ZXJDYXNlKCkgKyBcImpzXCIpO1xuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX2VzRGVjb3JhdGUsXG4gIF9fcnVuSW5pdGlhbGl6ZXJzLFxuICBfX3Byb3BLZXksXG4gIF9fc2V0RnVuY3Rpb25OYW1lLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fZXhwb3J0U3RhcixcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbixcbiAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UsXG4gIF9fZGlzcG9zZVJlc291cmNlcyxcbiAgX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24sXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/chemistry.ts":
/*!**************************!*\
  !*** ./src/chemistry.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $Chemical: () => (/* binding */ $Chemical),\n/* harmony export */   child: () => (/* binding */ child),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   entail: () => (/* binding */ entail),\n/* harmony export */   equate: () => (/* binding */ equate),\n/* harmony export */   fifth: () => (/* binding */ fifth),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   fourth: () => (/* binding */ fourth),\n/* harmony export */   inert: () => (/* binding */ inert),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   second: () => (/* binding */ second),\n/* harmony export */   third: () => (/* binding */ third),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   where: () => (/* binding */ where)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_ts_decorate */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ $Chemical,inert,equate,dynamic,entail,transform,child,optional,where,position,first,second,third,fourth,fifth auto */ \n\n// Symbol for tracking reactified objects\nconst reactivated = Symbol('reactivated');\nconst backingFields = Symbol('backingFields');\nconst originalValues = Symbol('originalValues');\nconst deactivated = Symbol('deactivated');\nconst comparerSymbol = Symbol('comparer');\n// Near the top of the file, with other symbols and constants\nconst componentUpdaters = new WeakMap();\n/**\n * Base class for Chemical components\n */ class $Chemical {\n    // Public methods\n    view() {\n        return this.elements;\n    }\n    // Private methods\n    createComponent() {\n        const self = this;\n        const ChemicalComponent = (props)=>{\n            const instance = self.createInstance();\n            const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n                \"ChemicalComponent.useEffect\": ()=>{\n                    self.setupInstance(instance, props, {\n                        \"ChemicalComponent.useEffect\": ()=>forceUpdate({})\n                    }[\"ChemicalComponent.useEffect\"]);\n                    return ({\n                        \"ChemicalComponent.useEffect\": ()=>self.cleanupInstance(instance)\n                    })[\"ChemicalComponent.useEffect\"];\n                }\n            }[\"ChemicalComponent.useEffect\"], []);\n            self.processChildren(instance, props);\n            return instance.view();\n        };\n        ChemicalComponent.isChemical = true;\n        return ChemicalComponent;\n    }\n    createInstance() {\n        const instance = Object.create(this);\n        instance.children = [];\n        return instance;\n    }\n    setupInstance(instance, props, forceUpdate) {\n        this.applyProps(instance, props);\n        this.setupReactivity(instance, forceUpdate);\n        this.handleParentBinding(instance, props);\n        this.runCatalystMethods(instance);\n    }\n    cleanupInstance(instance) {\n        componentUpdaters.delete(instance);\n        if (instance.parent) {\n            this.unregisterFromParent(instance, instance.parent);\n        }\n    }\n    applyProps(instance, props) {\n        if (!props) return;\n        for(const key in props){\n            if (props.hasOwnProperty(key) && key !== 'children' && key !== '__parentInstance') {\n                this.setProp(instance, key, props[key]);\n            }\n        }\n    }\n    setProp(instance, key, value) {\n        const componentKey = '$' + String(key);\n        const transformers = instance.constructor.prototype.transformers;\n        if (transformers === null || transformers === void 0 ? void 0 : transformers.has(componentKey)) {\n            const transformer = transformers.get(componentKey);\n            instance[componentKey] = transformer(value);\n        } else {\n            instance[componentKey] = value;\n        }\n    }\n    setupReactivity(instance, forceUpdate) {\n        componentUpdaters.set(instance, forceUpdate);\n        decorate(instance, {\n            after: (className, memberName, memberType, method, args, result)=>{\n                if (memberType === 'field') {\n                    const updateFn = componentUpdaters.get(instance);\n                    if (updateFn) updateFn();\n                }\n                return result;\n            }\n        });\n    }\n    handleParentBinding(instance, props) {\n        console.log('handleParentBinding called', props);\n        if (!props.__parentInstance) {\n            console.log('No parent instance in props');\n            return;\n        }\n        instance.parent = props.__parentInstance;\n        console.log('Registering child with parent: ' + props.__parentInstance);\n        if (instance.parent) this.registerWithParent(instance, instance.parent);\n    }\n    registerWithParent(child, parent) {\n        this.trackChild(parent, child);\n        this.applyBinding(child, parent);\n    }\n    trackChild(parent, child) {\n        if (!parent.children.includes(child)) {\n            parent.children.push(child);\n        }\n    }\n    untrackChild(parent, child) {\n        const index = parent.children.indexOf(child);\n        if (index >= 0) {\n            parent.children.splice(index, 1);\n        }\n    }\n    applyBinding(child, parent) {\n        const bindings = getBindings(parent);\n        console.log('applyBinding - bindings:', bindings);\n        console.log('applyBinding - child:', child);\n        console.log('applyBinding - parent:', parent);\n        if (!parent.childPositionCounts) {\n            parent.childPositionCounts = new Map();\n        }\n        for (const binding of bindings){\n            if (binding.property === 'children') continue;\n            console.log('Checking binding:', binding);\n            if (this.matchesBinding(child, parent, binding)) {\n                console.log('Binding matched! Applying...');\n                this.bindChild(child, parent, binding);\n                break;\n            }\n        }\n    }\n    matchesBinding(child, parent, binding) {\n        if (!(child instanceof binding.class)) return false;\n        if (binding.position !== undefined) {\n            const count = parent.childPositionCounts.get(binding.class) || 0;\n            if (binding.position !== count) {\n                parent.childPositionCounts.set(binding.class, count + 1);\n                return false;\n            }\n            parent.childPositionCounts.set(binding.class, count + 1);\n        }\n        if (binding.where && !binding.where(child)) return false;\n        return true;\n    }\n    bindChild(child, parent, binding) {\n        const prop = parent[binding.property];\n        if (Array.isArray(prop)) {\n            prop.push(child);\n        } else if (!parent[binding.property]) {\n            parent[binding.property] = child;\n        }\n    }\n    unbindChild(child, parent) {\n        const bindings = getBindings(parent);\n        for (const binding of bindings){\n            if (binding.property === 'children') continue;\n            const prop = parent[binding.property];\n            if (Array.isArray(prop)) {\n                const index = prop.indexOf(child);\n                if (index >= 0) prop.splice(index, 1);\n            } else if (parent[binding.property] === child) {\n                parent[binding.property] = undefined;\n            }\n        }\n    }\n    unregisterFromParent(child, parent) {\n        this.unbindChild(child, parent);\n        this.untrackChild(parent, child);\n    }\n    runCatalystMethods(instance) {\n        const methods = instance.constructor.prototype.catalystMethods;\n        if (!methods) return;\n        for (const methodName of methods){\n            if (typeof instance[methodName] === 'function') {\n                instance[methodName]();\n            }\n        }\n    }\n    processChildren(instance, props) {\n        if (!(props === null || props === void 0 ? void 0 : props.children)) return;\n        const modifiedChildren = this.modifyChildren(instance, props.children);\n        instance.elements = modifiedChildren;\n    }\n    modifyChildren(instance, children) {\n        console.log('modifyChildren called, instance:', instance);\n        const childrenArray = react__WEBPACK_IMPORTED_MODULE_0___default().Children.toArray(children);\n        console.log('childrenArray:', childrenArray);\n        return childrenArray.map((child)=>{\n            if (react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(child) && child.type.isChemical) {\n                console.log('Found Chemical child, adding __parentInstance');\n                return react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(child, {\n                    ...child.props,\n                    __parentInstance: instance\n                });\n            }\n            return child;\n        });\n    }\n    createFragment(above, main, below) {\n        const children = [];\n        if (above) children.push(above);\n        if (main) children.push(main);\n        if (below) children.push(below);\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, ...children);\n    }\n    // Constructor\n    constructor(){\n        this.children = [];\n        this.Component = this.createComponent();\n    }\n}\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__.__decorate)([\n    inert()\n], $Chemical.prototype, \"Component\", void 0);\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__.__decorate)([\n    inert()\n], $Chemical.prototype, \"parent\", void 0);\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__.__decorate)([\n    inert()\n], $Chemical.prototype, \"children\", void 0);\n(0,_swc_helpers_ts_decorate__WEBPACK_IMPORTED_MODULE_1__.__decorate)([\n    inert()\n], $Chemical.prototype, \"elements\", void 0);\n/**\n * Get merged bindings for a Chemical instance\n */ function getBindings(instance) {\n    const constructor = instance.constructor;\n    // Return cached if available\n    if (constructor._mergedBindings) {\n        return constructor._mergedBindings;\n    }\n    // Build merged map\n    const mergedMap = new Map();\n    // Walk up prototype chain, child bindings override parent\n    let proto = constructor;\n    while(proto && proto !== $Chemical){\n        if (proto.__bindingsMap) {\n            proto.__bindingsMap.forEach((binding, key)=>{\n                // Only add if not already set by child class\n                if (!mergedMap.has(key)) {\n                    mergedMap.set(key, {\n                        ...binding,\n                        property: key\n                    });\n                }\n            });\n        }\n        proto = Object.getPrototypeOf(proto);\n    }\n    // Convert to array, filter invalid, and sort\n    const bindings = [];\n    mergedMap.forEach((binding)=>{\n        if (!binding.class) {\n            console.warn(\"Binding for '\".concat(binding.property, \"' missing @child decorator\"));\n            return;\n        }\n        bindings.push(binding);\n    });\n    // Sort: indexed first, then by index value\n    bindings.sort((a, b)=>{\n        if (a.position !== undefined && b.position === undefined) return -1;\n        if (b.position !== undefined && a.position === undefined) return 1;\n        if (a.position !== undefined && b.position !== undefined) {\n            return a.position - b.position;\n        }\n        return 0;\n    });\n    // Cache and return\n    constructor._mergedBindings = bindings;\n    return bindings;\n}\n/**\n * Reactivates an object, making its properties reactive\n */ function reactivate(instance, owner) {\n    // Already marked as reactivated in component\n    if (instance[reactivated]) {\n        return instance;\n    }\n    instance[reactivated] = true;\n    const triggerUpdate = ()=>{\n        const updateFn = componentUpdaters.get(owner || instance);\n        if (updateFn) updateFn();\n    };\n    decorate(instance, {\n        after: (className, memberName, memberType, method, args, result)=>{\n            if (memberType === 'field') {\n                triggerUpdate();\n            }\n            return result;\n        }\n    });\n    // Only reactify non-Chemical objects\n    for(const key in instance){\n        if (key !== 'constructor' && !key.startsWith('_')) {\n            const value = instance[key];\n            // Skip Chemical instances - they manage themselves\n            if (!(value instanceof $Chemical) && value && typeof value === 'object' && !(value instanceof Date)) {\n                if (Array.isArray(value)) {\n                    value.forEach((item)=>{\n                        if (!(item instanceof $Chemical) && item && typeof item === 'object') {\n                            reactivateData(item, owner || instance);\n                        }\n                    });\n                } else {\n                    reactivateData(value, owner || instance);\n                }\n            }\n        }\n    }\n    return instance;\n}\n/**\n * Reactivates a nested data object in an object or field \n */ function reactivateData(obj, owner) {\n    if (!obj || typeof obj !== 'object' || obj[reactivated] || obj instanceof $Chemical) {\n        return;\n    }\n    reactivate(obj, owner);\n}\n/**\n * Deactivates an object, preventing it from triggering updates\n * This is exported for advanced usage but generally should be used via Chemical.deactivate\n */ function deactivate(instance) {\n    // Mark as deactivated\n    instance[deactivated] = true;\n    return instance;\n}\n/**\n * Decorator to mark a field as inert (non-reactive)\n */ function inert() {\n    return function(target, propertyKey) {\n        // Create or get the inert properties set\n        if (!target[deactivated]) {\n            target[deactivated] = new Set();\n        }\n        // Add this property to the inert set\n        target[deactivated].add(propertyKey);\n    };\n}\n/**\n * Decorator to specify a custom equality comparison for a field\n */ function equate(comparer) {\n    return function(target, propertyKey) {\n        // Create or get the property comparers map\n        if (!target[comparerSymbol]) {\n            target[comparerSymbol] = new Map();\n        }\n        // Add the custom comparer for this property\n        target[comparerSymbol].set(propertyKey, comparer);\n    };\n}\n/**\n * Decorator for properties that should use deep equality comparison\n * Useful for arrays, collections, and complex objects\n */ function dynamic() {\n    return function(target, propertyKey) {\n        // Create or get the property comparers map\n        if (!target[comparerSymbol]) {\n            target[comparerSymbol] = new Map();\n        }\n        // Add a JSON-based deep comparer for this property\n        target[comparerSymbol].set(propertyKey, (a, b)=>{\n            try {\n                return JSON.stringify(a) === JSON.stringify(b);\n            } catch (e) {\n                // If stringify fails (circular refs, etc.), fall back to reference equality\n                return a === b;\n            }\n        });\n    };\n}\n/**\n * Decorator for methods that should run after component rendering\n */ function entail() {\n    return function(target, propertyKey, descriptor) {\n        const originalMethod = descriptor.value;\n        // Create or get the catalysts methods set\n        if (!target.catalystMethods) {\n            target.catalystMethods = new Set();\n        }\n        // Add this method to the catalysts set\n        target.catalystMethods.add(propertyKey);\n        // Return the original descriptor\n        return descriptor;\n    };\n}\n/**\n * Decorator for properties that should run the value through a transformation function\n */ function transform(transformer) {\n    return function(target, propertyKey) {\n        // Create or get the transformers map\n        if (!target.transformers) {\n            target.transformers = new Map();\n        }\n        // Add the transformer for this property\n        target.transformers.set(propertyKey, transformer);\n    };\n}\n/**\n * Decorator for binding a child to a property\n */ function child(ChildClass) {\n    return function(target, propertyKey) {\n        const constructor = target.constructor;\n        if (!constructor.__bindingsMap) constructor.__bindingsMap = new Map();\n        let binding = constructor.__bindingsMap.get(propertyKey);\n        if (!binding) {\n            binding = {\n                property: propertyKey\n            };\n            constructor.__bindingsMap.set(propertyKey, binding);\n        }\n        binding.class = ChildClass;\n        if (binding.optional === undefined) binding.optional = false;\n    };\n}\n/**\n * Decorator for positional child property binding\n */ function optional() {\n    return function(target, propertyKey) {\n        const constructor = target.constructor;\n        if (!constructor.__bindingsMap) constructor.__bindingsMap = new Map();\n        let binding = constructor.__bindingsMap.get(propertyKey);\n        if (!binding) {\n            binding = {\n                property: propertyKey\n            };\n            constructor.__bindingsMap.set(propertyKey, binding);\n        }\n        binding.optional = true;\n    };\n}\n/**\n * Decorator for conditional child property binding\n */ function where(predicate) {\n    return function(target, propertyKey) {\n        const constructor = target.constructor;\n        if (!constructor.__bindingsMap) constructor.__bindingsMap = new Map();\n        let binding = constructor.__bindingsMap.get(propertyKey);\n        if (!binding) {\n            binding = {\n                property: propertyKey\n            };\n            constructor.__bindingsMap.set(propertyKey, binding);\n        }\n        binding.where = predicate;\n    };\n}\n/**\n * Decorator for positional child property binding\n */ function position(n) {\n    return function(target, propertyKey) {\n        const constructor = target.constructor;\n        if (!constructor.__bindingsMap) constructor.__bindingsMap = new Map();\n        let binding = constructor.__bindingsMap.get(propertyKey);\n        if (!binding) {\n            binding = {\n                property: propertyKey\n            };\n            constructor.__bindingsMap.set(propertyKey, binding);\n        }\n        binding.position = n - 1; // 0-based\n    };\n}\n// Convencience child binding decorators for different positions\nconst first = position(1);\nconst second = position(2);\nconst third = position(3);\nconst fourth = position(4);\nconst fifth = position(5);\n/**\n * Decorates an object's methods and properties with interceptors\n */ function decorate(instance, config) {\n    var _instance_constructor;\n    // Skip if already decorated\n    if (instance[reactivated]) {\n        return instance;\n    }\n    var _instance_constructor_name;\n    const className = (_instance_constructor_name = instance === null || instance === void 0 ? void 0 : (_instance_constructor = instance.constructor) === null || _instance_constructor === void 0 ? void 0 : _instance_constructor.name) !== null && _instance_constructor_name !== void 0 ? _instance_constructor_name : \"<UNKNOWN>\";\n    // Store original values\n    instance[backingFields] = {};\n    instance[originalValues] = {};\n    // Process properties and fields\n    decorateProperties(instance, className, config);\n    // Mark as reactified\n    instance[reactivated] = true;\n    return instance;\n}\n/**\n * Decorates properties of an object with interceptors\n */ function decorateProperties(instance, className, config) {\n    const properties = getAllProperties(instance);\n    for (const key of properties){\n        // Skip internal properties and methods we've already processed\n        if (key === 'constructor' || key === String(reactivated) || key === String(backingFields) || key === String(originalValues) || key === 'state' || key === 'props' || typeof instance[key] === 'function' || $Chemical.prototype.hasOwnProperty(key) || // Skip Chemical base class properties\n        instance[key] instanceof $Chemical) {\n            continue;\n        }\n        // Check if this is already an accessor property\n        const descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(instance), key);\n        if (descriptor && (descriptor.get || descriptor.set)) {\n            // Handle accessor property\n            decorateAccessorProperty(instance, key, descriptor, className, config);\n            continue;\n        }\n        // Handle regular data property\n        // Store original value\n        instance[backingFields][key] = instance[key];\n        // Replace with getter/setter for regular properties\n        Object.defineProperty(instance, key, {\n            get: function() {\n                const value = this[backingFields][key];\n                if (config.after) {\n                    const afterResult = config.after(className, key, 'property', ()=>{}, [], value);\n                    return afterResult !== null && afterResult !== void 0 ? afterResult : value;\n                }\n                return value;\n            },\n            set: function(newValue) {\n                const oldValue = this[backingFields][key];\n                // Skip update if values are equal\n                if (oldValue === newValue) {\n                    return;\n                }\n                // Check for custom comparer\n                const proto = Object.getPrototypeOf(this);\n                const hasCustomComparer = proto && proto[comparerSymbol] && proto[comparerSymbol].has(key);\n                if (hasCustomComparer) {\n                    const customComparer = proto[comparerSymbol].get(key);\n                    if (customComparer(oldValue, newValue)) {\n                        return; // Skip update if custom comparer says they're equal\n                    }\n                }\n                let valueToSet = newValue;\n                // Apply before logic if available\n                if (config.before) {\n                    const beforeResult = config.before(className, key, 'field', ()=>{}, [\n                        newValue\n                    ]);\n                    if (beforeResult && beforeResult[1]) {\n                        valueToSet = beforeResult[1][0];\n                    }\n                }\n                // Handle frozen/sealed objects\n                if (valueToSet && typeof valueToSet === 'object') {\n                    // Skip reactification for frozen/sealed objects and Chemical instances\n                    if (!Object.isFrozen(valueToSet) && !Object.isSealed(valueToSet) && Object.isExtensible(valueToSet) && !(valueToSet instanceof $Chemical)) {\n                        // Deep reactify complex objects\n                        if (!Array.isArray(valueToSet) && !(valueToSet instanceof Date)) {\n                            reactivateData(valueToSet, this);\n                        }\n                    }\n                }\n                // Set the new value\n                this[backingFields][key] = valueToSet;\n                // Apply after logic\n                if (config.after) {\n                    config.after(className, key, 'field', ()=>{}, [\n                        valueToSet\n                    ], undefined);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n    }\n}\n/**\n * Decorates an accessor property (getter/setter)\n */ function decorateAccessorProperty(instance, key, descriptor, className, config) {\n    const originalGet = descriptor.get;\n    const originalSet = descriptor.set;\n    Object.defineProperty(instance, key, {\n        get: function() {\n            // Preserve original getter behavior\n            const value = originalGet === null || originalGet === void 0 ? void 0 : originalGet.call(this);\n            if (config.after) {\n                const afterResult = config.after(className, key, 'property', ()=>{}, [], value);\n                return afterResult !== null && afterResult !== void 0 ? afterResult : value;\n            }\n            return value;\n        },\n        set: function(newValue) {\n            if (!originalSet) return; // Read-only property\n            const oldValue = originalGet === null || originalGet === void 0 ? void 0 : originalGet.call(this);\n            // Skip update if values are equal\n            if (oldValue === newValue) {\n                return;\n            }\n            // Check for custom comparer\n            const proto = Object.getPrototypeOf(this);\n            const hasCustomComparer = proto && proto[comparerSymbol] && proto[comparerSymbol].has(key);\n            if (hasCustomComparer) {\n                const customComparer = proto[comparerSymbol].get(key);\n                if (customComparer(oldValue, newValue)) {\n                    return; // Skip update if custom comparer says they're equal\n                }\n            }\n            // Call original setter\n            originalSet.call(this, newValue);\n            // Apply after logic to trigger updates\n            if (config.after) {\n                config.after(className, key, 'field', ()=>{}, [\n                    newValue\n                ], undefined);\n            }\n        },\n        enumerable: descriptor.enumerable,\n        configurable: descriptor.configurable\n    });\n}\n/**\n * Checks if an object is a base object method\n */ function isBaseObjectMethod(methodName) {\n    return Object.prototype.hasOwnProperty.call(Object.prototype, methodName);\n}\n/**\n * Gets all methods from an object and its prototype chain\n */ function getAllMethods(obj) {\n    const methods = {};\n    let proto = obj;\n    while(proto && proto !== Object.prototype){\n        for(const key in proto){\n            if (methods[key]) continue;\n            if (typeof proto[key] === \"function\" && !key.startsWith(\"_\") && // Skip private methods\n            !isBaseObjectMethod(key)) {\n                methods[key] = proto[key];\n            }\n        }\n        proto = proto.__proto__;\n    }\n    return methods;\n}\n/**\n * Gets all properties from an object\n */ function getAllProperties(obj) {\n    const properties = new Set();\n    // Get own properties\n    Object.getOwnPropertyNames(obj).forEach((prop)=>{\n        properties.add(prop);\n    });\n    // Get properties from prototype chain\n    let proto = Object.getPrototypeOf(obj);\n    while(proto && proto !== Object.prototype){\n        Object.getOwnPropertyNames(proto).forEach((prop)=>{\n            if (!prop.startsWith('_') && prop !== 'constructor') {\n                properties.add(prop);\n            }\n        });\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Array.from(properties);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TXJDLFVBQXVDLENBQUM7SUFDOUMsSUFBSXNCLFFBQVFlO0lBRVosTUFBT2YsU0FBU0EsVUFBVW5GLE9BQU9pQixTQUFTLENBQUU7UUFDeEMsSUFBSyxNQUFNUCxPQUFPeUUsTUFBTztZQUNyQixJQUFJdEIsT0FBTyxDQUFDbkQsSUFBSSxFQUFFO1lBQ2xCLElBQ0ksT0FBT3lFLEtBQUssQ0FBQ3pFLElBQUksS0FBSyxjQUN0QixDQUFDQSxJQUFJb0YsVUFBVSxDQUFDLFFBQVEsdUJBQXVCO1lBQy9DLENBQUNzRCxtQkFBbUIxSSxNQUN0QjtnQkFDRW1ELE9BQU8sQ0FBQ25ELElBQUksR0FBR3lFLEtBQUssQ0FBQ3pFLElBQUk7WUFDN0I7UUFDSjtRQUNBeUUsUUFBUUEsTUFBTW1FLFNBQVM7SUFDM0I7SUFFQSxPQUFPekY7QUFDWDtBQUVBOztDQUVDLEdBQ0QsU0FBU21FLGlCQUFpQjlCLEdBQVE7SUFDOUIsTUFBTTZCLGFBQWEsSUFBSXhCO0lBRXZCLHFCQUFxQjtJQUNyQnZHLE9BQU91SixtQkFBbUIsQ0FBQ3JELEtBQUtiLE9BQU8sQ0FBQzVCLENBQUFBO1FBQ3BDc0UsV0FBV3ZCLEdBQUcsQ0FBQy9DO0lBQ25CO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUkwQixRQUFRbkYsT0FBT3NGLGNBQWMsQ0FBQ1k7SUFDbEMsTUFBT2YsU0FBU0EsVUFBVW5GLE9BQU9pQixTQUFTLENBQUU7UUFDeENqQixPQUFPdUosbUJBQW1CLENBQUNwRSxPQUFPRSxPQUFPLENBQUM1QixDQUFBQTtZQUN0QyxJQUFJLENBQUNBLEtBQUtxQyxVQUFVLENBQUMsUUFBUXJDLFNBQVMsZUFBZTtnQkFDakRzRSxXQUFXdkIsR0FBRyxDQUFDL0M7WUFDbkI7UUFDSjtRQUNBMEIsUUFBUW5GLE9BQU9zRixjQUFjLENBQUNIO0lBQ2xDO0lBRUEsT0FBT3pCLE1BQU04RixJQUFJLENBQUN6QjtBQUN0QiIsInNvdXJjZXMiOlsiL2hvbWUvZG91Zy9yZXBvcy9kbmEtcGxhdGZvcm0vY2hlbWlzdHJ5L3NyYy9jaGVtaXN0cnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCBSZWFjdCwgeyBSZWFjdE5vZGUsIFJlYWN0RWxlbWVudCwgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyBTeW1ib2wgZm9yIHRyYWNraW5nIHJlYWN0aWZpZWQgb2JqZWN0c1xuY29uc3QgcmVhY3RpdmF0ZWQgPSBTeW1ib2woJ3JlYWN0aXZhdGVkJyk7XG5jb25zdCBiYWNraW5nRmllbGRzID0gU3ltYm9sKCdiYWNraW5nRmllbGRzJyk7XG5jb25zdCBvcmlnaW5hbFZhbHVlcyA9IFN5bWJvbCgnb3JpZ2luYWxWYWx1ZXMnKTtcbmNvbnN0IGRlYWN0aXZhdGVkID0gU3ltYm9sKCdkZWFjdGl2YXRlZCcpO1xuY29uc3QgY29tcGFyZXJTeW1ib2wgPSBTeW1ib2woJ2NvbXBhcmVyJyk7XG5cbi8vIE5lYXIgdGhlIHRvcCBvZiB0aGUgZmlsZSwgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCBjb25zdGFudHNcbmNvbnN0IGNvbXBvbmVudFVwZGF0ZXJzID0gbmV3IFdlYWtNYXA8b2JqZWN0LCAoKSA9PiB2b2lkPigpO1xuXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IGFsbG93cyB5b3UgdG8gdXNlIGZpZWxkcyBwcmVmaXhlZCB3aXRoICQgYXMgcHJvcHNcbiAqL1xudHlwZSBQcm9wZXJ0aWVzPFQ+ID0ge1xuICAgIFtLIGluIGtleW9mIFQgYXMgSyBleHRlbmRzIGAkJHtpbmZlciBSZXN0fWAgPyBSZXN0IDogbmV2ZXJdOiBUW0tdXG59ICYge1xuICAgIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBDaGVtaWNhbCBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyAkQ2hlbWljYWwge1xuICAgIC8vIFByaXZhdGUgZmllbGRzXG4gICAgcHJpdmF0ZSBjaGlsZFBvc2l0aW9uQ291bnRzPzogTWFwPGFueSwgbnVtYmVyPjtcblxuICAgIC8vIFB1YmxpYyBpbmVydCBwcm9wZXJ0aWVzXG4gICAgQGluZXJ0KClcbiAgICBwdWJsaWMgQ29tcG9uZW50ITogUmVhY3QuRkM8UHJvcGVydGllczx0aGlzPj47XG5cbiAgICBAaW5lcnQoKVxuICAgIHB1YmxpYyBwYXJlbnQ/OiAkQ2hlbWljYWw7XG5cbiAgICBAaW5lcnQoKVxuICAgIHB1YmxpYyBjaGlsZHJlbjogJENoZW1pY2FsW10gPSBbXTtcblxuICAgIEBpbmVydCgpXG4gICAgcHVibGljIGVsZW1lbnRzPzogUmVhY3ROb2RlO1xuXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5Db21wb25lbnQgPSB0aGlzLmNyZWF0ZUNvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIC8vIFB1YmxpYyBtZXRob2RzXG4gICAgdmlldygpOiBSZWFjdE5vZGUge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgICBwcml2YXRlIGNyZWF0ZUNvbXBvbmVudCgpOiBSZWFjdC5GQzxQcm9wZXJ0aWVzPHRoaXM+PiB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IENoZW1pY2FsQ29tcG9uZW50OiBSZWFjdC5GQzxQcm9wZXJ0aWVzPHRoaXM+PiA9IChwcm9wczogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHNlbGYuY3JlYXRlSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKHt9KTtcblxuICAgICAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldHVwSW5zdGFuY2UoaW5zdGFuY2UsIHByb3BzLCAoKSA9PiBmb3JjZVVwZGF0ZSh7fSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBzZWxmLmNsZWFudXBJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgIHNlbGYucHJvY2Vzc0NoaWxkcmVuKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UudmlldygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIChDaGVtaWNhbENvbXBvbmVudCBhcyBhbnkpLmlzQ2hlbWljYWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gQ2hlbWljYWxDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVJbnN0YW5jZSgpOiAkQ2hlbWljYWwge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgIGluc3RhbmNlLmNoaWxkcmVuID0gW107XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwSW5zdGFuY2UoaW5zdGFuY2U6ICRDaGVtaWNhbCwgcHJvcHM6IGFueSwgZm9yY2VVcGRhdGU6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hcHBseVByb3BzKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICAgIHRoaXMuc2V0dXBSZWFjdGl2aXR5KGluc3RhbmNlLCBmb3JjZVVwZGF0ZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFyZW50QmluZGluZyhpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgICB0aGlzLnJ1bkNhdGFseXN0TWV0aG9kcyhpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbGVhbnVwSW5zdGFuY2UoaW5zdGFuY2U6ICRDaGVtaWNhbCk6IHZvaWQge1xuICAgICAgICBjb21wb25lbnRVcGRhdGVycy5kZWxldGUoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJGcm9tUGFyZW50KGluc3RhbmNlLCBpbnN0YW5jZS5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseVByb3BzKGluc3RhbmNlOiAkQ2hlbWljYWwsIHByb3BzOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFwcm9wcykgcmV0dXJuO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ2NoaWxkcmVuJyAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ19fcGFyZW50SW5zdGFuY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9wKGluc3RhbmNlLCBrZXksIHByb3BzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRQcm9wKGluc3RhbmNlOiAkQ2hlbWljYWwsIGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEtleSA9ICckJyArIFN0cmluZyhrZXkpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHJhbnNmb3JtZXJzO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lcnM/Lmhhcyhjb21wb25lbnRLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVycy5nZXQoY29tcG9uZW50S2V5KTtcbiAgICAgICAgICAgIChpbnN0YW5jZSBhcyBhbnkpW2NvbXBvbmVudEtleV0gPSB0cmFuc2Zvcm1lcih2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAoaW5zdGFuY2UgYXMgYW55KVtjb21wb25lbnRLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwUmVhY3Rpdml0eShpbnN0YW5jZTogJENoZW1pY2FsLCBmb3JjZVVwZGF0ZTogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBjb21wb25lbnRVcGRhdGVycy5zZXQoaW5zdGFuY2UsIGZvcmNlVXBkYXRlKTtcblxuICAgICAgICBkZWNvcmF0ZShpbnN0YW5jZSwge1xuICAgICAgICAgICAgYWZ0ZXI6IChjbGFzc05hbWUsIG1lbWJlck5hbWUsIG1lbWJlclR5cGUsIG1ldGhvZCwgYXJncywgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbWJlclR5cGUgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlRm4gPSBjb21wb25lbnRVcGRhdGVycy5nZXQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlRm4pIHVwZGF0ZUZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlUGFyZW50QmluZGluZyhpbnN0YW5jZTogJENoZW1pY2FsLCBwcm9wczogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoYW5kbGVQYXJlbnRCaW5kaW5nIGNhbGxlZCcsIHByb3BzKTtcbiAgICAgICAgaWYgKCFwcm9wcy5fX3BhcmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gcGFyZW50IGluc3RhbmNlIGluIHByb3BzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0YW5jZS5wYXJlbnQgPSBwcm9wcy5fX3BhcmVudEluc3RhbmNlO1xuICAgICAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgY2hpbGQgd2l0aCBwYXJlbnQ6ICcgKyBwcm9wcy5fX3BhcmVudEluc3RhbmNlKTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJXaXRoUGFyZW50KGluc3RhbmNlLCBpbnN0YW5jZS5wYXJlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVnaXN0ZXJXaXRoUGFyZW50KGNoaWxkOiAkQ2hlbWljYWwsIHBhcmVudDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIHRoaXMudHJhY2tDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgdGhpcy5hcHBseUJpbmRpbmcoY2hpbGQsIHBhcmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmFja0NoaWxkKHBhcmVudDogJENoZW1pY2FsLCBjaGlsZDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIGlmICghcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKGNoaWxkKSkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bnRyYWNrQ2hpbGQocGFyZW50OiAkQ2hlbWljYWwsIGNoaWxkOiAkQ2hlbWljYWwpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXBwbHlCaW5kaW5nKGNoaWxkOiAkQ2hlbWljYWwsIHBhcmVudDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gZ2V0QmluZGluZ3MocGFyZW50KTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FwcGx5QmluZGluZyAtIGJpbmRpbmdzOicsIGJpbmRpbmdzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FwcGx5QmluZGluZyAtIGNoaWxkOicsIGNoaWxkKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FwcGx5QmluZGluZyAtIHBhcmVudDonLCBwYXJlbnQpO1xuXG4gICAgICAgIGlmICghcGFyZW50LmNoaWxkUG9zaXRpb25Db3VudHMpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZFBvc2l0aW9uQ291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoYmluZGluZy5wcm9wZXJ0eSA9PT0gJ2NoaWxkcmVuJykgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBiaW5kaW5nOicsIGJpbmRpbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hlc0JpbmRpbmcoY2hpbGQsIHBhcmVudCwgYmluZGluZykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmluZGluZyBtYXRjaGVkISBBcHBseWluZy4uLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZENoaWxkKGNoaWxkLCBwYXJlbnQsIGJpbmRpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXRjaGVzQmluZGluZyhjaGlsZDogJENoZW1pY2FsLCBwYXJlbnQ6ICRDaGVtaWNhbCwgYmluZGluZzogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgYmluZGluZy5jbGFzcyEpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKGJpbmRpbmcucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBwYXJlbnQuY2hpbGRQb3NpdGlvbkNvdW50cyEuZ2V0KGJpbmRpbmcuY2xhc3MpIHx8IDA7XG4gICAgICAgICAgICBpZiAoYmluZGluZy5wb3NpdGlvbiAhPT0gY291bnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRQb3NpdGlvbkNvdW50cyEuc2V0KGJpbmRpbmcuY2xhc3MhLCBjb3VudCArIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5jaGlsZFBvc2l0aW9uQ291bnRzIS5zZXQoYmluZGluZy5jbGFzcyEsIGNvdW50ICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmluZGluZy53aGVyZSAmJiAhYmluZGluZy53aGVyZShjaGlsZCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGJpbmRDaGlsZChjaGlsZDogJENoZW1pY2FsLCBwYXJlbnQ6ICRDaGVtaWNhbCwgYmluZGluZzogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHByb3AgPSAocGFyZW50IGFzIGFueSlbYmluZGluZy5wcm9wZXJ0eV07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgIHByb3AucHVzaChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIShwYXJlbnQgYXMgYW55KVtiaW5kaW5nLnByb3BlcnR5XSkge1xuICAgICAgICAgICAgKHBhcmVudCBhcyBhbnkpW2JpbmRpbmcucHJvcGVydHldID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVuYmluZENoaWxkKGNoaWxkOiAkQ2hlbWljYWwsIHBhcmVudDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gZ2V0QmluZGluZ3MocGFyZW50KTtcblxuICAgICAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnByb3BlcnR5ID09PSAnY2hpbGRyZW4nKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgcHJvcCA9IChwYXJlbnQgYXMgYW55KVtiaW5kaW5nLnByb3BlcnR5XTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcm9wLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSBwcm9wLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChwYXJlbnQgYXMgYW55KVtiaW5kaW5nLnByb3BlcnR5XSA9PT0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAocGFyZW50IGFzIGFueSlbYmluZGluZy5wcm9wZXJ0eV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVucmVnaXN0ZXJGcm9tUGFyZW50KGNoaWxkOiAkQ2hlbWljYWwsIHBhcmVudDogJENoZW1pY2FsKTogdm9pZCB7XG4gICAgICAgIHRoaXMudW5iaW5kQ2hpbGQoY2hpbGQsIHBhcmVudCk7XG4gICAgICAgIHRoaXMudW50cmFja0NoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcnVuQ2F0YWx5c3RNZXRob2RzKGluc3RhbmNlOiAkQ2hlbWljYWwpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IGluc3RhbmNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYXRhbHlzdE1ldGhvZHM7XG4gICAgICAgIGlmICghbWV0aG9kcykgcmV0dXJuO1xuXG4gICAgICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBtZXRob2RzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChpbnN0YW5jZSBhcyBhbnkpW21ldGhvZE5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgKGluc3RhbmNlIGFzIGFueSlbbWV0aG9kTmFtZV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcHJvY2Vzc0NoaWxkcmVuKGluc3RhbmNlOiAkQ2hlbWljYWwsIHByb3BzOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFwcm9wcz8uY2hpbGRyZW4pIHJldHVybjtcblxuICAgICAgICBjb25zdCBtb2RpZmllZENoaWxkcmVuID0gdGhpcy5tb2RpZnlDaGlsZHJlbihpbnN0YW5jZSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBpbnN0YW5jZS5lbGVtZW50cyA9IG1vZGlmaWVkQ2hpbGRyZW47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb2RpZnlDaGlsZHJlbihpbnN0YW5jZTogJENoZW1pY2FsLCBjaGlsZHJlbjogUmVhY3ROb2RlKTogUmVhY3ROb2RlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ21vZGlmeUNoaWxkcmVuIGNhbGxlZCwgaW5zdGFuY2U6JywgaW5zdGFuY2UpO1xuICAgICAgICBjb25zdCBjaGlsZHJlbkFycmF5ID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjaGlsZHJlbkFycmF5OicsIGNoaWxkcmVuQXJyYXkpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZHJlbkFycmF5Lm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIChjaGlsZC50eXBlIGFzIGFueSkuaXNDaGVtaWNhbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBDaGVtaWNhbCBjaGlsZCwgYWRkaW5nIF9fcGFyZW50SW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkIGFzIGFueSwge1xuICAgICAgICAgICAgICAgICAgICAuLi4oY2hpbGQucHJvcHMgYXMgYW55KSxcbiAgICAgICAgICAgICAgICAgICAgX19wYXJlbnRJbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVGcmFnbWVudChhYm92ZT86IFJlYWN0Tm9kZSwgbWFpbj86IFJlYWN0Tm9kZSwgYmVsb3c/OiBSZWFjdE5vZGUpOiBSZWFjdE5vZGUge1xuICAgICAgICBjb25zdCBjaGlsZHJlbjogUmVhY3ROb2RlW10gPSBbXTtcblxuICAgICAgICBpZiAoYWJvdmUpIGNoaWxkcmVuLnB1c2goYWJvdmUpO1xuICAgICAgICBpZiAobWFpbikgY2hpbGRyZW4ucHVzaChtYWluKTtcbiAgICAgICAgaWYgKGJlbG93KSBjaGlsZHJlbi5wdXNoKGJlbG93KTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgbWVyZ2VkIGJpbmRpbmdzIGZvciBhIENoZW1pY2FsIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldEJpbmRpbmdzKGluc3RhbmNlOiAkQ2hlbWljYWwpOiBhbnlbXSB7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBpbnN0YW5jZS5jb25zdHJ1Y3RvciBhcyBhbnk7XG5cbiAgICAvLyBSZXR1cm4gY2FjaGVkIGlmIGF2YWlsYWJsZVxuICAgIGlmIChjb25zdHJ1Y3Rvci5fbWVyZ2VkQmluZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLl9tZXJnZWRCaW5kaW5ncztcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBtZXJnZWQgbWFwXG4gICAgY29uc3QgbWVyZ2VkTWFwID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICAgIC8vIFdhbGsgdXAgcHJvdG90eXBlIGNoYWluLCBjaGlsZCBiaW5kaW5ncyBvdmVycmlkZSBwYXJlbnRcbiAgICBsZXQgcHJvdG8gPSBjb25zdHJ1Y3RvcjtcbiAgICB3aGlsZSAocHJvdG8gJiYgcHJvdG8gIT09ICRDaGVtaWNhbCkge1xuICAgICAgICBpZiAocHJvdG8uX19iaW5kaW5nc01hcCkge1xuICAgICAgICAgICAgcHJvdG8uX19iaW5kaW5nc01hcC5mb3JFYWNoKChiaW5kaW5nOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgaWYgbm90IGFscmVhZHkgc2V0IGJ5IGNoaWxkIGNsYXNzXG4gICAgICAgICAgICAgICAgaWYgKCFtZXJnZWRNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTWFwLnNldChrZXksIHsgLi4uYmluZGluZywgcHJvcGVydHk6IGtleSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0byBhcnJheSwgZmlsdGVyIGludmFsaWQsIGFuZCBzb3J0XG4gICAgY29uc3QgYmluZGluZ3M6IGFueVtdID0gW107XG4gICAgbWVyZ2VkTWFwLmZvckVhY2goYmluZGluZyA9PiB7XG4gICAgICAgIGlmICghYmluZGluZy5jbGFzcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBCaW5kaW5nIGZvciAnJHtiaW5kaW5nLnByb3BlcnR5fScgbWlzc2luZyBAY2hpbGQgZGVjb3JhdG9yYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICB9KTtcblxuICAgIC8vIFNvcnQ6IGluZGV4ZWQgZmlyc3QsIHRoZW4gYnkgaW5kZXggdmFsdWVcbiAgICBiaW5kaW5ncy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgYi5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChiLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgYS5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBiLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIC8vIENhY2hlIGFuZCByZXR1cm5cbiAgICBjb25zdHJ1Y3Rvci5fbWVyZ2VkQmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICByZXR1cm4gYmluZGluZ3M7XG59XG5cbi8qKlxuICogUmVhY3RpdmF0ZXMgYW4gb2JqZWN0LCBtYWtpbmcgaXRzIHByb3BlcnRpZXMgcmVhY3RpdmVcbiAqL1xuZnVuY3Rpb24gcmVhY3RpdmF0ZTxUIGV4dGVuZHMgb2JqZWN0PihpbnN0YW5jZTogVCwgb3duZXI/OiBhbnkpOiBUIHtcbiAgICAvLyBBbHJlYWR5IG1hcmtlZCBhcyByZWFjdGl2YXRlZCBpbiBjb21wb25lbnRcbiAgICBpZiAoKGluc3RhbmNlIGFzIGFueSlbcmVhY3RpdmF0ZWRdKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICAoaW5zdGFuY2UgYXMgYW55KVtyZWFjdGl2YXRlZF0gPSB0cnVlO1xuXG4gICAgY29uc3QgdHJpZ2dlclVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlRm4gPSBjb21wb25lbnRVcGRhdGVycy5nZXQob3duZXIgfHwgaW5zdGFuY2UpO1xuICAgICAgICBpZiAodXBkYXRlRm4pIHVwZGF0ZUZuKCk7XG4gICAgfTtcblxuICAgIGRlY29yYXRlKGluc3RhbmNlLCB7XG4gICAgICAgIGFmdGVyOiAoY2xhc3NOYW1lLCBtZW1iZXJOYW1lLCBtZW1iZXJUeXBlLCBtZXRob2QsIGFyZ3MsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lbWJlclR5cGUgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBPbmx5IHJlYWN0aWZ5IG5vbi1DaGVtaWNhbCBvYmplY3RzXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiAha2V5LnN0YXJ0c1dpdGgoJ18nKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5zdGFuY2UgYXMgYW55KVtrZXldO1xuICAgICAgICAgICAgLy8gU2tpcCBDaGVtaWNhbCBpbnN0YW5jZXMgLSB0aGV5IG1hbmFnZSB0aGVtc2VsdmVzXG4gICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mICRDaGVtaWNhbCkgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiAkQ2hlbWljYWwpICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhY3RpdmF0ZURhdGEoaXRlbSwgb3duZXIgfHwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWFjdGl2YXRlRGF0YSh2YWx1ZSwgb3duZXIgfHwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdGl2YXRlcyBhIG5lc3RlZCBkYXRhIG9iamVjdCBpbiBhbiBvYmplY3Qgb3IgZmllbGQgXG4gKi9cbmZ1bmN0aW9uIHJlYWN0aXZhdGVEYXRhKG9iajogYW55LCBvd25lcjogYW55KSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgKG9iaiBhcyBhbnkpW3JlYWN0aXZhdGVkXSB8fCBvYmogaW5zdGFuY2VvZiAkQ2hlbWljYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlYWN0aXZhdGUob2JqLCBvd25lcik7XG59XG5cbi8qKlxuICogRGVhY3RpdmF0ZXMgYW4gb2JqZWN0LCBwcmV2ZW50aW5nIGl0IGZyb20gdHJpZ2dlcmluZyB1cGRhdGVzXG4gKiBUaGlzIGlzIGV4cG9ydGVkIGZvciBhZHZhbmNlZCB1c2FnZSBidXQgZ2VuZXJhbGx5IHNob3VsZCBiZSB1c2VkIHZpYSBDaGVtaWNhbC5kZWFjdGl2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlYWN0aXZhdGU8VCBleHRlbmRzIG9iamVjdD4oaW5zdGFuY2U6IFQpOiBUIHtcbiAgICAvLyBNYXJrIGFzIGRlYWN0aXZhdGVkXG4gICAgKGluc3RhbmNlIGFzIGFueSlbZGVhY3RpdmF0ZWRdID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIHRvIG1hcmsgYSBmaWVsZCBhcyBpbmVydCAobm9uLXJlYWN0aXZlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5lcnQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICAgICAgICAvLyBDcmVhdGUgb3IgZ2V0IHRoZSBpbmVydCBwcm9wZXJ0aWVzIHNldFxuICAgICAgICBpZiAoIXRhcmdldFtkZWFjdGl2YXRlZCBhcyBhbnldKSB7XG4gICAgICAgICAgICB0YXJnZXRbZGVhY3RpdmF0ZWQgYXMgYW55XSA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoaXMgcHJvcGVydHkgdG8gdGhlIGluZXJ0IHNldFxuICAgICAgICB0YXJnZXRbZGVhY3RpdmF0ZWQgYXMgYW55XS5hZGQocHJvcGVydHlLZXkpO1xuICAgIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIHRvIHNwZWNpZnkgYSBjdXN0b20gZXF1YWxpdHkgY29tcGFyaXNvbiBmb3IgYSBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YXRlKGNvbXBhcmVyOiAoYTogYW55LCBiOiBhbnkpID0+IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvciBnZXQgdGhlIHByb3BlcnR5IGNvbXBhcmVycyBtYXBcbiAgICAgICAgaWYgKCF0YXJnZXRbY29tcGFyZXJTeW1ib2wgYXMgYW55XSkge1xuICAgICAgICAgICAgdGFyZ2V0W2NvbXBhcmVyU3ltYm9sIGFzIGFueV0gPSBuZXcgTWFwPHN0cmluZywgKGE6IGFueSwgYjogYW55KSA9PiBib29sZWFuPigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSBjdXN0b20gY29tcGFyZXIgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgICAgdGFyZ2V0W2NvbXBhcmVyU3ltYm9sIGFzIGFueV0uc2V0KHByb3BlcnR5S2V5LCBjb21wYXJlcik7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgZm9yIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgdXNlIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvblxuICogVXNlZnVsIGZvciBhcnJheXMsIGNvbGxlY3Rpb25zLCBhbmQgY29tcGxleCBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBzdHJpbmcpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG9yIGdldCB0aGUgcHJvcGVydHkgY29tcGFyZXJzIG1hcFxuICAgICAgICBpZiAoIXRhcmdldFtjb21wYXJlclN5bWJvbCBhcyBhbnldKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29tcGFyZXJTeW1ib2wgYXMgYW55XSA9IG5ldyBNYXA8c3RyaW5nLCAoYTogYW55LCBiOiBhbnkpID0+IGJvb2xlYW4+KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYSBKU09OLWJhc2VkIGRlZXAgY29tcGFyZXIgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgICAgdGFyZ2V0W2NvbXBhcmVyU3ltYm9sIGFzIGFueV0uc2V0KHByb3BlcnR5S2V5LCAoYTogYW55LCBiOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdHJpbmdpZnkgZmFpbHMgKGNpcmN1bGFyIHJlZnMsIGV0Yy4pLCBmYWxsIGJhY2sgdG8gcmVmZXJlbmNlIGVxdWFsaXR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZvciBtZXRob2RzIHRoYXQgc2hvdWxkIHJ1biBhZnRlciBjb21wb25lbnQgcmVuZGVyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnRhaWwoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcblxuICAgICAgICAvLyBDcmVhdGUgb3IgZ2V0IHRoZSBjYXRhbHlzdHMgbWV0aG9kcyBzZXRcbiAgICAgICAgaWYgKCF0YXJnZXQuY2F0YWx5c3RNZXRob2RzKSB7XG4gICAgICAgICAgICB0YXJnZXQuY2F0YWx5c3RNZXRob2RzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhpcyBtZXRob2QgdG8gdGhlIGNhdGFseXN0cyBzZXRcbiAgICAgICAgdGFyZ2V0LmNhdGFseXN0TWV0aG9kcy5hZGQocHJvcGVydHlLZXkpO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgb3JpZ2luYWwgZGVzY3JpcHRvclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9O1xufVxuXG4vKipcbiAqIERlY29yYXRvciBmb3IgcHJvcGVydGllcyB0aGF0IHNob3VsZCBydW4gdGhlIHZhbHVlIHRocm91Z2ggYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybWVyOiAodmFsdWU6IGFueSkgPT4gYW55KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICAgICAgICAvLyBDcmVhdGUgb3IgZ2V0IHRoZSB0cmFuc2Zvcm1lcnMgbWFwXG4gICAgICAgIGlmICghdGFyZ2V0LnRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgdGFyZ2V0LnRyYW5zZm9ybWVycyA9IG5ldyBNYXA8c3RyaW5nLCAodmFsdWU6IGFueSkgPT4gYW55PigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSB0cmFuc2Zvcm1lciBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAgICB0YXJnZXQudHJhbnNmb3JtZXJzLnNldChwcm9wZXJ0eUtleSwgdHJhbnNmb3JtZXIpO1xuICAgIH07XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBiaW5kaW5nIGRlY29yYXRvcnNcbiAqL1xuaW50ZXJmYWNlIEJpbmRpbmcge1xuICAgIGNsYXNzPzogdHlwZW9mICRDaGVtaWNhbDsgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjbGFzcyB0byBiaW5kXG4gICAgb3B0aW9uYWw/OiBib29sZWFuOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGV0aGVyIGJpbmRpbmcgaXMgb3B0aW9uYWxcbiAgICBwb3NpdGlvbj86IG51bWJlcjsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBAZmlyc3QsIEBzZWNvbmQsIGV0YyAoMC1iYXNlZClcbiAgICB3aGVyZT86IChpbnN0YW5jZTogYW55KSA9PiBib29sZWFuOyAgICAgICAgIC8vIENvbmRpdGlvbmFsIHByZWRpY2F0ZVxuICAgIHByb3BlcnR5OiBzdHJpbmc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydHkgbmFtZSAoZm9yIGNvbnZlbmllbmNlKVxufVxuXG4vKipcbiAqIERlY29yYXRvciBmb3IgYmluZGluZyBhIGNoaWxkIHRvIGEgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkKENoaWxkQ2xhc3M6IGFueSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3IgYXMgYW55O1xuICAgICAgICBpZiAoIWNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXApIGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAgPSBuZXcgTWFwPHN0cmluZywgQmluZGluZz4oKTtcblxuICAgICAgICBsZXQgYmluZGluZyA9IGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAuZ2V0KHByb3BlcnR5S2V5KTtcbiAgICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5nID0geyBwcm9wZXJ0eTogcHJvcGVydHlLZXkgfTtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAuc2V0KHByb3BlcnR5S2V5LCBiaW5kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRpbmcuY2xhc3MgPSBDaGlsZENsYXNzO1xuICAgICAgICBpZiAoYmluZGluZy5vcHRpb25hbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYmluZGluZy5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZvciBwb3NpdGlvbmFsIGNoaWxkIHByb3BlcnR5IGJpbmRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3IgYXMgYW55O1xuICAgICAgICBpZiAoIWNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXApIGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAgPSBuZXcgTWFwPHN0cmluZywgQmluZGluZz4oKTtcblxuICAgICAgICBsZXQgYmluZGluZyA9IGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAuZ2V0KHByb3BlcnR5S2V5KTtcbiAgICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5nID0geyBwcm9wZXJ0eTogcHJvcGVydHlLZXkgfTtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLl9fYmluZGluZ3NNYXAuc2V0KHByb3BlcnR5S2V5LCBiaW5kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRpbmcub3B0aW9uYWwgPSB0cnVlO1xuICAgIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZvciBjb25kaXRpb25hbCBjaGlsZCBwcm9wZXJ0eSBiaW5kaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aGVyZShwcmVkaWNhdGU6IChpbnN0YW5jZTogJENoZW1pY2FsKSA9PiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvciBhcyBhbnk7XG4gICAgICAgIGlmICghY29uc3RydWN0b3IuX19iaW5kaW5nc01hcCkgY29uc3RydWN0b3IuX19iaW5kaW5nc01hcCA9IG5ldyBNYXA8c3RyaW5nLCBCaW5kaW5nPigpO1xuXG4gICAgICAgIGxldCBiaW5kaW5nID0gY29uc3RydWN0b3IuX19iaW5kaW5nc01hcC5nZXQocHJvcGVydHlLZXkpO1xuICAgICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgICAgIGJpbmRpbmcgPSB7IHByb3BlcnR5OiBwcm9wZXJ0eUtleSB9O1xuICAgICAgICAgICAgY29uc3RydWN0b3IuX19iaW5kaW5nc01hcC5zZXQocHJvcGVydHlLZXksIGJpbmRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluZGluZy53aGVyZSA9IHByZWRpY2F0ZTtcbiAgICB9O1xufVxuXG4vKipcbiAqIERlY29yYXRvciBmb3IgcG9zaXRpb25hbCBjaGlsZCBwcm9wZXJ0eSBiaW5kaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3NpdGlvbihuOiBudW1iZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yIGFzIGFueTtcbiAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvci5fX2JpbmRpbmdzTWFwKSBjb25zdHJ1Y3Rvci5fX2JpbmRpbmdzTWFwID0gbmV3IE1hcDxzdHJpbmcsIEJpbmRpbmc+KCk7XG5cbiAgICAgICAgbGV0IGJpbmRpbmcgPSBjb25zdHJ1Y3Rvci5fX2JpbmRpbmdzTWFwLmdldChwcm9wZXJ0eUtleSk7XG4gICAgICAgIGlmICghYmluZGluZykge1xuICAgICAgICAgICAgYmluZGluZyA9IHsgcHJvcGVydHk6IHByb3BlcnR5S2V5IH07XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5fX2JpbmRpbmdzTWFwLnNldChwcm9wZXJ0eUtleSwgYmluZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBiaW5kaW5nLnBvc2l0aW9uID0gbiAtIDE7ICAvLyAwLWJhc2VkXG4gICAgfTtcbn1cblxuLy8gQ29udmVuY2llbmNlIGNoaWxkIGJpbmRpbmcgZGVjb3JhdG9ycyBmb3IgZGlmZmVyZW50IHBvc2l0aW9uc1xuZXhwb3J0IGNvbnN0IGZpcnN0ID0gcG9zaXRpb24oMSk7XG5leHBvcnQgY29uc3Qgc2Vjb25kID0gcG9zaXRpb24oMik7XG5leHBvcnQgY29uc3QgdGhpcmQgPSBwb3NpdGlvbigzKTtcbmV4cG9ydCBjb25zdCBmb3VydGggPSBwb3NpdGlvbig0KTtcbmV4cG9ydCBjb25zdCBmaWZ0aCA9IHBvc2l0aW9uKDUpO1xuXG4vLyBUeXBlIGRlZmluaXRpb25zIGZvciBkZWNvcmF0b3IgY29uZmlndXJhdGlvblxudHlwZSBNZW1iZXJUeXBlID0gJ21ldGhvZCcgfCAncHJvcGVydHknIHwgJ2ZpZWxkJztcbnR5cGUgRGVjb3JhdG9yQ29uZmlnID0ge1xuICAgIGJlZm9yZT86IChcbiAgICAgICAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gICAgICAgIG1lbWJlck5hbWU6IHN0cmluZyxcbiAgICAgICAgbWVtYmVyVHlwZTogTWVtYmVyVHlwZSxcbiAgICAgICAgbWV0aG9kOiBGdW5jdGlvbixcbiAgICAgICAgYXJnczogYW55W11cbiAgICApID0+IFtGdW5jdGlvbiwgYW55W11dIHwgdW5kZWZpbmVkO1xuICAgIGFmdGVyPzogKFxuICAgICAgICBjbGFzc05hbWU6IHN0cmluZyxcbiAgICAgICAgbWVtYmVyTmFtZTogc3RyaW5nLFxuICAgICAgICBtZW1iZXJUeXBlOiBNZW1iZXJUeXBlLFxuICAgICAgICBtZXRob2Q6IEZ1bmN0aW9uLFxuICAgICAgICBhcmdzOiBhbnlbXSxcbiAgICAgICAgcmVzdWx0OiBhbnlcbiAgICApID0+IGFueSB8IHVuZGVmaW5lZDtcbiAgICBlcnJvcj86IChcbiAgICAgICAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gICAgICAgIG1lbWJlck5hbWU6IHN0cmluZyxcbiAgICAgICAgbWVtYmVyVHlwZTogTWVtYmVyVHlwZSxcbiAgICAgICAgbWV0aG9kOiBGdW5jdGlvbixcbiAgICAgICAgYXJnczogYW55W10sXG4gICAgICAgIGVycm9yOiBhbnlcbiAgICApID0+IGFueSB8IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRGVjb3JhdGVzIGFuIG9iamVjdCdzIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgd2l0aCBpbnRlcmNlcHRvcnNcbiAqL1xuZnVuY3Rpb24gZGVjb3JhdGU8VCBleHRlbmRzIG9iamVjdD4oaW5zdGFuY2U6IFQsIGNvbmZpZzogRGVjb3JhdG9yQ29uZmlnKTogVCB7XG4gICAgLy8gU2tpcCBpZiBhbHJlYWR5IGRlY29yYXRlZFxuICAgIGlmICgoaW5zdGFuY2UgYXMgYW55KVtyZWFjdGl2YXRlZF0pIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzTmFtZTogc3RyaW5nID0gaW5zdGFuY2U/LmNvbnN0cnVjdG9yPy5uYW1lID8/IFwiPFVOS05PV04+XCI7XG5cbiAgICAvLyBTdG9yZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAoaW5zdGFuY2UgYXMgYW55KVtiYWNraW5nRmllbGRzXSA9IHt9O1xuICAgIChpbnN0YW5jZSBhcyBhbnkpW29yaWdpbmFsVmFsdWVzXSA9IHt9O1xuXG4gICAgLy8gUHJvY2VzcyBwcm9wZXJ0aWVzIGFuZCBmaWVsZHNcbiAgICBkZWNvcmF0ZVByb3BlcnRpZXMoaW5zdGFuY2UsIGNsYXNzTmFtZSwgY29uZmlnKTtcblxuICAgIC8vIE1hcmsgYXMgcmVhY3RpZmllZFxuICAgIChpbnN0YW5jZSBhcyBhbnkpW3JlYWN0aXZhdGVkXSA9IHRydWU7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8qKlxuICogRGVjb3JhdGVzIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IHdpdGggaW50ZXJjZXB0b3JzXG4gKi9cbmZ1bmN0aW9uIGRlY29yYXRlUHJvcGVydGllcyhpbnN0YW5jZTogYW55LCBjbGFzc05hbWU6IHN0cmluZywgY29uZmlnOiBEZWNvcmF0b3JDb25maWcpOiB2b2lkIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2V0QWxsUHJvcGVydGllcyhpbnN0YW5jZSk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIFNraXAgaW50ZXJuYWwgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB3ZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InIHx8XG4gICAgICAgICAgICBrZXkgPT09IFN0cmluZyhyZWFjdGl2YXRlZCkgfHxcbiAgICAgICAgICAgIGtleSA9PT0gU3RyaW5nKGJhY2tpbmdGaWVsZHMpIHx8XG4gICAgICAgICAgICBrZXkgPT09IFN0cmluZyhvcmlnaW5hbFZhbHVlcykgfHxcbiAgICAgICAgICAgIGtleSA9PT0gJ3N0YXRlJyB8fCBrZXkgPT09ICdwcm9wcycgfHxcbiAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZVtrZXldID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAkQ2hlbWljYWwucHJvdG90eXBlLmhhc093blByb3BlcnR5KGtleSkgfHwgICAgLy8gU2tpcCBDaGVtaWNhbCBiYXNlIGNsYXNzIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGluc3RhbmNlW2tleV0gaW5zdGFuY2VvZiAkQ2hlbWljYWwpIHsgICAgICAgICAvLyBTa2lwIENoZW1pY2FsIGluc3RhbmNlc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFscmVhZHkgYW4gYWNjZXNzb3IgcHJvcGVydHlcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5zdGFuY2UsIGtleSkgfHxcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3RhbmNlKSwga2V5KTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci5nZXQgfHwgZGVzY3JpcHRvci5zZXQpKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYWNjZXNzb3IgcHJvcGVydHlcbiAgICAgICAgICAgIGRlY29yYXRlQWNjZXNzb3JQcm9wZXJ0eShpbnN0YW5jZSwga2V5LCBkZXNjcmlwdG9yLCBjbGFzc05hbWUsIGNvbmZpZyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSByZWd1bGFyIGRhdGEgcHJvcGVydHlcbiAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgaW5zdGFuY2VbYmFja2luZ0ZpZWxkc11ba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbiAgICAgICAgLy8gUmVwbGFjZSB3aXRoIGdldHRlci9zZXR0ZXIgZm9yIHJlZ3VsYXIgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIGtleSwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2JhY2tpbmdGaWVsZHNdW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyUmVzdWx0ID0gY29uZmlnLmFmdGVyKGNsYXNzTmFtZSwga2V5LCAncHJvcGVydHknLCAoKSA9PiB7IH0sIFtdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZnRlclJlc3VsdCA/PyB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbYmFja2luZ0ZpZWxkc11ba2V5XTtcblxuICAgICAgICAgICAgICAgIC8vIFNraXAgdXBkYXRlIGlmIHZhbHVlcyBhcmUgZXF1YWxcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgY3VzdG9tIGNvbXBhcmVyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzQ3VzdG9tQ29tcGFyZXIgPSBwcm90byAmJlxuICAgICAgICAgICAgICAgICAgICBwcm90b1tjb21wYXJlclN5bWJvbCBhcyBhbnldICYmXG4gICAgICAgICAgICAgICAgICAgIHByb3RvW2NvbXBhcmVyU3ltYm9sIGFzIGFueV0uaGFzKGtleSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQ3VzdG9tQ29tcGFyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tQ29tcGFyZXIgPSBwcm90b1tjb21wYXJlclN5bWJvbCBhcyBhbnldLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQ29tcGFyZXIob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTa2lwIHVwZGF0ZSBpZiBjdXN0b20gY29tcGFyZXIgc2F5cyB0aGV5J3JlIGVxdWFsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVUb1NldCA9IG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgYmVmb3JlIGxvZ2ljIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZVJlc3VsdCA9IGNvbmZpZy5iZWZvcmUoY2xhc3NOYW1lLCBrZXksICdmaWVsZCcsICgpID0+IHsgfSwgW25ld1ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVSZXN1bHQgJiYgYmVmb3JlUmVzdWx0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVRvU2V0ID0gYmVmb3JlUmVzdWx0WzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZyb3plbi9zZWFsZWQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVRvU2V0ICYmIHR5cGVvZiB2YWx1ZVRvU2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHJlYWN0aWZpY2F0aW9uIGZvciBmcm96ZW4vc2VhbGVkIG9iamVjdHMgYW5kIENoZW1pY2FsIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZVRvU2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5pc1NlYWxlZCh2YWx1ZVRvU2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZVRvU2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgISh2YWx1ZVRvU2V0IGluc3RhbmNlb2YgJENoZW1pY2FsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVlcCByZWFjdGlmeSBjb21wbGV4IG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZVRvU2V0KSAmJiAhKHZhbHVlVG9TZXQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0aXZhdGVEYXRhKHZhbHVlVG9TZXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzW2JhY2tpbmdGaWVsZHNdW2tleV0gPSB2YWx1ZVRvU2V0O1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgYWZ0ZXIgbG9naWNcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5hZnRlcihjbGFzc05hbWUsIGtleSwgJ2ZpZWxkJywgKCkgPT4geyB9LCBbdmFsdWVUb1NldF0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIERlY29yYXRlcyBhbiBhY2Nlc3NvciBwcm9wZXJ0eSAoZ2V0dGVyL3NldHRlcilcbiAqL1xuZnVuY3Rpb24gZGVjb3JhdGVBY2Nlc3NvclByb3BlcnR5KFxuICAgIGluc3RhbmNlOiBhbnksXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGNsYXNzTmFtZTogc3RyaW5nLFxuICAgIGNvbmZpZzogRGVjb3JhdG9yQ29uZmlnXG4pOiB2b2lkIHtcbiAgICBjb25zdCBvcmlnaW5hbEdldCA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgIGNvbnN0IG9yaWdpbmFsU2V0ID0gZGVzY3JpcHRvci5zZXQ7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIG9yaWdpbmFsIGdldHRlciBiZWhhdmlvclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvcmlnaW5hbEdldD8uY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5hZnRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyUmVzdWx0ID0gY29uZmlnLmFmdGVyKGNsYXNzTmFtZSwga2V5LCAncHJvcGVydHknLCAoKSA9PiB7IH0sIFtdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyUmVzdWx0ID8/IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIW9yaWdpbmFsU2V0KSByZXR1cm47IC8vIFJlYWQtb25seSBwcm9wZXJ0eVxuXG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9yaWdpbmFsR2V0Py5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBTa2lwIHVwZGF0ZSBpZiB2YWx1ZXMgYXJlIGVxdWFsXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3VzdG9tIGNvbXBhcmVyXG4gICAgICAgICAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0N1c3RvbUNvbXBhcmVyID0gcHJvdG8gJiZcbiAgICAgICAgICAgICAgICBwcm90b1tjb21wYXJlclN5bWJvbCBhcyBhbnldICYmXG4gICAgICAgICAgICAgICAgcHJvdG9bY29tcGFyZXJTeW1ib2wgYXMgYW55XS5oYXMoa2V5KTtcblxuICAgICAgICAgICAgaWYgKGhhc0N1c3RvbUNvbXBhcmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tQ29tcGFyZXIgPSBwcm90b1tjb21wYXJlclN5bWJvbCBhcyBhbnldLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21Db21wYXJlcihvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU2tpcCB1cGRhdGUgaWYgY3VzdG9tIGNvbXBhcmVyIHNheXMgdGhleSdyZSBlcXVhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCBvcmlnaW5hbCBzZXR0ZXJcbiAgICAgICAgICAgIG9yaWdpbmFsU2V0LmNhbGwodGhpcywgbmV3VmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBhZnRlciBsb2dpYyB0byB0cmlnZ2VyIHVwZGF0ZXNcbiAgICAgICAgICAgIGlmIChjb25maWcuYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuYWZ0ZXIoY2xhc3NOYW1lLCBrZXksICdmaWVsZCcsICgpID0+IHsgfSwgW25ld1ZhbHVlXSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9iamVjdCBpcyBhIGJhc2Ugb2JqZWN0IG1ldGhvZFxuICovXG5mdW5jdGlvbiBpc0Jhc2VPYmplY3RNZXRob2QobWV0aG9kTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChPYmplY3QucHJvdG90eXBlLCBtZXRob2ROYW1lKTtcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCBtZXRob2RzIGZyb20gYW4gb2JqZWN0IGFuZCBpdHMgcHJvdG90eXBlIGNoYWluXG4gKi9cbmZ1bmN0aW9uIGdldEFsbE1ldGhvZHMob2JqOiBhbnkpOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uIH0ge1xuICAgIGNvbnN0IG1ldGhvZHM6IHsgW2tleTogc3RyaW5nXTogRnVuY3Rpb24gfSA9IHt9O1xuICAgIGxldCBwcm90byA9IG9iajtcblxuICAgIHdoaWxlIChwcm90byAmJiBwcm90byAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm90bykge1xuICAgICAgICAgICAgaWYgKG1ldGhvZHNba2V5XSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIHByb3RvW2tleV0gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICFrZXkuc3RhcnRzV2l0aChcIl9cIikgJiYgLy8gU2tpcCBwcml2YXRlIG1ldGhvZHNcbiAgICAgICAgICAgICAgICAhaXNCYXNlT2JqZWN0TWV0aG9kKGtleSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1ldGhvZHNba2V5XSA9IHByb3RvW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8gPSBwcm90by5fX3Byb3RvX187XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZHM7XG59XG5cbi8qKlxuICogR2V0cyBhbGwgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRBbGxQcm9wZXJ0aWVzKG9iajogYW55KTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIC8vIEdldCBvd24gcHJvcGVydGllc1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgcHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgfSk7XG5cbiAgICAvLyBHZXQgcHJvcGVydGllcyBmcm9tIHByb3RvdHlwZSBjaGFpblxuICAgIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIHdoaWxlIChwcm90byAmJiBwcm90byAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIGlmICghcHJvcC5zdGFydHNXaXRoKCdfJykgJiYgcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5mcm9tKHByb3BlcnRpZXMpO1xufSJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwicmVhY3RpdmF0ZWQiLCJTeW1ib2wiLCJiYWNraW5nRmllbGRzIiwib3JpZ2luYWxWYWx1ZXMiLCJkZWFjdGl2YXRlZCIsImNvbXBhcmVyU3ltYm9sIiwiY29tcG9uZW50VXBkYXRlcnMiLCJXZWFrTWFwIiwiJENoZW1pY2FsIiwidmlldyIsImVsZW1lbnRzIiwiY3JlYXRlQ29tcG9uZW50Iiwic2VsZiIsIkNoZW1pY2FsQ29tcG9uZW50IiwicHJvcHMiLCJpbnN0YW5jZSIsImNyZWF0ZUluc3RhbmNlIiwiZm9yY2VVcGRhdGUiLCJzZXR1cEluc3RhbmNlIiwiY2xlYW51cEluc3RhbmNlIiwicHJvY2Vzc0NoaWxkcmVuIiwiaXNDaGVtaWNhbCIsIk9iamVjdCIsImNyZWF0ZSIsImNoaWxkcmVuIiwiYXBwbHlQcm9wcyIsInNldHVwUmVhY3Rpdml0eSIsImhhbmRsZVBhcmVudEJpbmRpbmciLCJydW5DYXRhbHlzdE1ldGhvZHMiLCJkZWxldGUiLCJwYXJlbnQiLCJ1bnJlZ2lzdGVyRnJvbVBhcmVudCIsImtleSIsImhhc093blByb3BlcnR5Iiwic2V0UHJvcCIsInZhbHVlIiwiY29tcG9uZW50S2V5IiwiU3RyaW5nIiwidHJhbnNmb3JtZXJzIiwicHJvdG90eXBlIiwiaGFzIiwidHJhbnNmb3JtZXIiLCJnZXQiLCJzZXQiLCJkZWNvcmF0ZSIsImFmdGVyIiwiY2xhc3NOYW1lIiwibWVtYmVyTmFtZSIsIm1lbWJlclR5cGUiLCJtZXRob2QiLCJhcmdzIiwicmVzdWx0IiwidXBkYXRlRm4iLCJjb25zb2xlIiwibG9nIiwiX19wYXJlbnRJbnN0YW5jZSIsInJlZ2lzdGVyV2l0aFBhcmVudCIsImNoaWxkIiwidHJhY2tDaGlsZCIsImFwcGx5QmluZGluZyIsImluY2x1ZGVzIiwicHVzaCIsInVudHJhY2tDaGlsZCIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImJpbmRpbmdzIiwiZ2V0QmluZGluZ3MiLCJjaGlsZFBvc2l0aW9uQ291bnRzIiwiTWFwIiwiYmluZGluZyIsInByb3BlcnR5IiwibWF0Y2hlc0JpbmRpbmciLCJiaW5kQ2hpbGQiLCJjbGFzcyIsInBvc2l0aW9uIiwidW5kZWZpbmVkIiwiY291bnQiLCJ3aGVyZSIsInByb3AiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmJpbmRDaGlsZCIsIm1ldGhvZHMiLCJjYXRhbHlzdE1ldGhvZHMiLCJtZXRob2ROYW1lIiwibW9kaWZpZWRDaGlsZHJlbiIsIm1vZGlmeUNoaWxkcmVuIiwiY2hpbGRyZW5BcnJheSIsIkNoaWxkcmVuIiwidG9BcnJheSIsIm1hcCIsImlzVmFsaWRFbGVtZW50IiwidHlwZSIsImNsb25lRWxlbWVudCIsImNyZWF0ZUZyYWdtZW50IiwiYWJvdmUiLCJtYWluIiwiYmVsb3ciLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsIl9tZXJnZWRCaW5kaW5ncyIsIm1lcmdlZE1hcCIsInByb3RvIiwiX19iaW5kaW5nc01hcCIsImZvckVhY2giLCJnZXRQcm90b3R5cGVPZiIsIndhcm4iLCJzb3J0IiwiYSIsImIiLCJyZWFjdGl2YXRlIiwib3duZXIiLCJ0cmlnZ2VyVXBkYXRlIiwic3RhcnRzV2l0aCIsIkRhdGUiLCJpdGVtIiwicmVhY3RpdmF0ZURhdGEiLCJvYmoiLCJkZWFjdGl2YXRlIiwiaW5lcnQiLCJ0YXJnZXQiLCJwcm9wZXJ0eUtleSIsIlNldCIsImFkZCIsImVxdWF0ZSIsImNvbXBhcmVyIiwiZHluYW1pYyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiZW50YWlsIiwiZGVzY3JpcHRvciIsIm9yaWdpbmFsTWV0aG9kIiwidHJhbnNmb3JtIiwiQ2hpbGRDbGFzcyIsIm9wdGlvbmFsIiwicHJlZGljYXRlIiwibiIsImZpcnN0Iiwic2Vjb25kIiwidGhpcmQiLCJmb3VydGgiLCJmaWZ0aCIsImNvbmZpZyIsIm5hbWUiLCJkZWNvcmF0ZVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwiZ2V0QWxsUHJvcGVydGllcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlY29yYXRlQWNjZXNzb3JQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiYWZ0ZXJSZXN1bHQiLCJuZXdWYWx1ZSIsIm9sZFZhbHVlIiwiaGFzQ3VzdG9tQ29tcGFyZXIiLCJjdXN0b21Db21wYXJlciIsInZhbHVlVG9TZXQiLCJiZWZvcmUiLCJiZWZvcmVSZXN1bHQiLCJpc0Zyb3plbiIsImlzU2VhbGVkIiwiaXNFeHRlbnNpYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIm9yaWdpbmFsR2V0Iiwib3JpZ2luYWxTZXQiLCJjYWxsIiwiaXNCYXNlT2JqZWN0TWV0aG9kIiwiZ2V0QWxsTWV0aG9kcyIsIl9fcHJvdG9fXyIsImdldE93blByb3BlcnR5TmFtZXMiLCJmcm9tIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/chemistry.ts\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fdoug%2Frepos%2Fdna-platform%2Fchemistry%2Fapp%2Ftests%2Fproperty-binding%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);